#include "hybrid/code_generator.hpp"
#include <fstream>
#include <sstream>

namespace hybrid {

CodeGenerator::CodeGenerator() {}

CodeGenerator& CodeGenerator::instance() {
   static CodeGenerator ce;
   return ce;
}

const std::string CodeGenerator::generatePureTyperQ1() {
   // generate code
   const std::string filename = "src/hybrid/pure_typer_q1";
   const std::string cppName = filename + ".cpp";
   std::ofstream f(cppName);
   f << "#include \"hybrid/minimal_api.hpp\"\n"
        "using namespace runtime;\n"
        "using namespace std;\n"
        "using namespace types;\n"
        "std::unique_ptr<runtime::Query> pure_typer_q18(Database& db, size_t nrThreads) {\n"
        "    using namespace types;\n"
        "    using namespace std;\n"
        "    using hash = runtime::CRC32Hash;\n"
        "    auto resources = initQuery(nrThreads);\n"
        "\n"
        "    auto total_time = std::chrono::steady_clock::now();\n"
        "    auto& li = db[\"lineitem\"];\n"
        "    auto l_orderkey = li[\"l_orderkey\"].data<types::Integer>();\n"
        "    auto l_quantity = li[\"l_quantity\"].data<types::Numeric<12, 2>>();\n"
        "    tbb::enumerable_thread_specific<Hashmapx<types::Integer, types::Numeric<12, 2>, hash, false>>groups;\n"
        "    const auto zero = types::Numeric<12, 2>::castString(\"0.00\");\n"
        "    auto groupOp = make_GroupBy<types::Integer, types::Numeric<12, 2>, hash>([](auto& acc, auto&& value) {\n"
        "        acc += value;\n"
        "    }, zero, nrThreads);// scan lineitem and group by l_orderkey\n"
        "\n"
        "    auto p1_start = std::chrono::steady_clock::now();\n"
        "    tbb::parallel_for(tbb::blocked_range<size_t>(0, li.nrTuples, morselSize),[&](const tbb::blocked_range<size_t>& r) {\n"
        "        auto locals = groupOp.preAggLocals();\n"
        "        for (size_t i = r.begin(), end = r.end(); i != end; ++i) {\n"
        "            auto& group = locals.getGroup(l_orderkey[i]);\n"
        "            group += l_quantity[i];// locals.consume(l_orderkey[i], l_quantity[i]);\n"
        "        }\n"
        "    });\n"
        "    auto p2_start = std::chrono::steady_clock::now();\n"
        "\n"
        "    Hashset<types::Integer, hash> ht1;\n"
        "    tbb::enumerable_thread_specific<runtime::Stack<decltype(ht1)::Entry>>entries1;\n"
        "    const auto threeHundret = types::Numeric<12, 2>::castString(\"300\");\n"
        "    std::atomic<size_t> nrGroups;\n"
        "    nrGroups = 0;\n"
        "    groupOp.forallGroups([&](auto& groups) {\n"
        "        auto& entries = entries1.local();\n"
        "        size_t groupsFound = 0;\n"
        "        for (auto block : groups)for (auto& group : block)if (group.v > threeHundret) {\n"
        "                    entries.emplace_back(ht1.hash(group.k), group.k);\n"
        "                    groupsFound++;\n"
        "                }\n"
        "// TODO: reconsider this way of counting groups\n"
        "        nrGroups.fetch_add(groupsFound);\n"
        "    });\n"
//        "    std::cout<<\"nrGroups: \"<<nrGroups<<std::endl;\n"
        "    ht1.setSize(nrGroups);\n"
        "    parallel_insert(entries1, ht1);\n"
        "\n"
        "    auto p3_start = std::chrono::steady_clock::now();\n"
        "\n"
        "// build customer hashtable\n"
        "    auto& cu = db[\"customer\"];\n"
        "    auto c_custkey = cu[\"c_custkey\"].data<types::Integer>();\n"
        "    auto c_name = cu[\"c_name\"].data<types::Char<25>>();\n"
        "    Hashmapx<types::Integer, types::Char<25>, hash> ht2;\n"
        "    tbb::enumerable_thread_specific<runtime::Stack<decltype(ht2)::Entry>>entries2;\n"
        "    PARALLEL_SCAN(cu.nrTuples, entries2, {entries.emplace_back(ht2.hash(c_custkey[i]), c_custkey[i], c_name[i]);});\n"
        "    ht2.setSize(cu.nrTuples);\n"
        "    parallel_insert(entries2, ht2);\n"
        "// build last hashtable\n"
        "    Hashmapx<types::Integer,std::tuple<types::Integer, types::Date, types::Numeric<12, 2>,types::Char<25>>,hash>ht3;\n"
        "    tbb::enumerable_thread_specific<runtime::Stack<decltype(ht3)::Entry>>entries3;\n"
        "    auto& ord = db[\"orders\"];\n"
        "    auto o_orderkey = ord[\"o_orderkey\"].data<types::Integer>();\n"
        "    auto o_custkey = ord[\"o_custkey\"].data<types::Integer>();\n"
        "    auto o_orderdate = ord[\"o_orderdate\"].data<types::Date>();\n"
        "    auto o_totalprice = ord[\"o_totalprice\"].data<types::Numeric<12, 2>>();\n"
        "// scan orders\n"
        "    auto found = PARALLEL_SELECT(ord.nrTuples, entries3, {types::Char<25>* name;\n"
        "// check if it matches the order criteria and look up the customer name\n"
        "    if (ht1.contains(o_orderkey[i]) && (name = ht2.findOne(o_custkey[i]))) {\n"
        "    entries.emplace_back(ht3.hash(o_orderkey[i]), o_orderkey[i],make_tuple(o_custkey[i], o_orderdate[i], o_totalprice[i], *name));\n"
        "        found++;\n"
        "    }\n"
        "                                                         });\n"
        "    ht3.setSize(found);\n"
        "    parallel_insert(entries3, ht3);\n"
        "\n"
        "    auto p4_start = std::chrono::steady_clock::now();\n"
        "\n"
        "    auto finalGroupOp = make_GroupBy<std::tuple<types::Integer, types::Date, types::Numeric<12, 2>,types::Char<25>, types::Integer>,types::Numeric<12, 2>, hash>([](auto& acc, auto&& value) {\n"
        "        acc += value;\n"
        "    }, zero, nrThreads);\n"
        "// scan lineitem and group by l_orderkey\n"
        "    tbb::parallel_for(tbb::blocked_range<size_t>(0, li.nrTuples, morselSize),[&](const tbb::blocked_range<size_t>& r) {\n"
        "        auto locals = finalGroupOp.preAggLocals();\n"
        "        for (size_t i = r.begin(), end = r.end(); i != end; ++i) {\n"
        "            std::tuple<types::Integer, types::Date, types::Numeric<12, 2>,types::Char<25>>* v;\n"
        "            if ((v = ht3.findOne(l_orderkey[i]))) {\n"
        "                auto& group =locals.getGroup(tuple_cat(*v, make_tuple(l_orderkey[i])));\n"
        "                group += l_quantity[i];\n"
        "            }\n"
        "        }\n"
        "    });\n"
        "    auto& result = resources.query->result;\n"
        "    auto namAttr = result->addAttribute(\"c_name\", sizeof(types::Char<25>));\n"
        "    auto ckyAttr = result->addAttribute(\"c_custkey\", sizeof(types::Integer));\n"
        "    auto okyAttr = result->addAttribute(\"o_orderkey\", sizeof(types::Integer));\n"
        "    auto datAttr = result->addAttribute(\"o_orderdate\", sizeof(types::Date));\n"
        "    auto totAttr =result->addAttribute(\"o_totalprice\", sizeof(types::Numeric<12, 2>));\n"
        "    auto sumAttr = result->addAttribute(\"sum\", sizeof(types::Numeric<12, 2>));\n"
        "    finalGroupOp.forallGroups([&](auto& groups) {\n"
        "// write aggregates to result\n"
        "        auto n = groups.size();\n"
        "        auto block = result->createBlock(n);\n"
        "        auto name = reinterpret_cast<types::Char<25>*>(block.data(namAttr));\n"
        "        auto cky = reinterpret_cast<types::Integer*>(block.data(ckyAttr));\n"
        "        auto oky = reinterpret_cast<types::Integer*>(block.data(okyAttr));\n"
        "        auto dat = reinterpret_cast<types::Date*>(block.data(datAttr));\n"
        "        auto tot = reinterpret_cast<types::Numeric<12, 2>*>(block.data(totAttr));\n"
        "        auto sum = reinterpret_cast<types::Numeric<12, 2>*>(block.data(sumAttr));\n"
        "        for (auto block : groups)for (auto& group : block) {\n"
        "                auto& k = group.k;\n"
        "                *name++ = std::get<3>(k);\n"
        "                *cky++ = get<0>(k);\n"
        "                *oky++ = get<4>(k);\n"
        "                *dat++ = get<1>(k);\n"
        "                *tot++ = get<2>(k);\n"
        "                *sum++ = group.v;\n"
        "            }\n"
        "        block.addedElements(n);\n"
        "    });\n"
        "\n"
        "    auto total_time_end = std::chrono::steady_clock::now();\n"
        "    std::cout\n"
        "//            << \"P1: \"\n"
        "//            << std::chrono::duration_cast<std::chrono::milliseconds>(p2_start - p1_start)\n"
        "//                    .count()<<\",\"\n"
        "            << \"P2: \"\n"
        "            << std::chrono::duration_cast<std::chrono::milliseconds>(p3_start - p2_start)\n"
        "                    .count()<<\",\"\n"
        "//            << \"P3: \"\n"
        "//            << std::chrono::duration_cast<std::chrono::milliseconds>(p4_start - p3_start)\n"
        "//                    .count()<<\",\"\n"
        "//            << \"P4: \"\n"
        "//            << std::chrono::duration_cast<std::chrono::milliseconds>(total_time_end -\n"
        "//                                                                     p4_start)\n"
        "//                    .count()<<\",\"\n"
        "            << \"Total time \"\n"
        "            << std::chrono::duration_cast<std::chrono::milliseconds>(\n"
        "                    total_time_end  - total_time)\n"
        "                    .count()\n"
        "            << \" milliseconds.\" << std::endl;\n"
        "\n"
        "    leaveQuery(nrThreads);\n"
        "    return move(resources.query);\n"
        "}";
   f.close();

   // format code
   std::string format_command = std::string("astyle -q ") + cppName;
   system(format_command.c_str());

   return filename;
}

const std::string CodeGenerator::generatePureTyperQ3() {
   // generate code
   const std::string filename = "src/hybrid/pure_typer_q3";
   const std::string cppName = filename + ".cpp";
   std::ofstream f(cppName);
   f << "#include \"hybrid/minimal_api.hpp\"\n"
        "using namespace runtime;\n"
        "using namespace std;\n"
        "using namespace types;\n"
        "std::unique_ptr<runtime::Query> q3_hyper(Database& db,\n"
        "        size_t nrThreads) {\n"
        "    auto q3_hyper_start = std::chrono::steady_clock::now();\n"
        "    auto resources = initQuery(nrThreads);\n"
        "\n"
        "    // --- constants\n"
        "    auto c1 = types::Date::castString(\"1995-03-15\");\n"
        "    auto c2 = types::Date::castString(\"1995-03-15\");\n"
        "    string b = \"BUILDING\";\n"
        "    auto c3 = types::Char<10>::castString(b.data(), b.size());\n"
        "\n"
        "    auto& cu = db[\"customer\"];\n"
        "    auto& ord = db[\"orders\"];\n"
        "    auto& li = db[\"lineitem\"];\n"
        "\n"
        "    auto c_mktsegment = cu[\"c_mktsegment\"].data<types::Char<10>>();\n"
        "    auto c_custkey = cu[\"c_custkey\"].data<types::Integer>();\n"
        "    auto o_custkey = ord[\"o_custkey\"].data<types::Integer>();\n"
        "    auto o_orderkey = ord[\"o_orderkey\"].data<types::Integer>();\n"
        "    auto o_orderdate = ord[\"o_orderdate\"].data<types::Date>();\n"
        "    auto o_shippriority = ord[\"o_shippriority\"].data<types::Integer>();\n"
        "    auto l_orderkey = li[\"l_orderkey\"].data<types::Integer>();\n"
        "    auto l_shipdate = li[\"l_shipdate\"].data<types::Date>();\n"
        "    auto l_extendedprice =\n"
        "        li[\"l_extendedprice\"].data<types::Numeric<12, 2>>();\n"
        "    auto l_discount = li[\"l_discount\"].data<types::Numeric<12, 2>>();\n"
        "\n"
        "    using hash = runtime::CRC32Hash;\n"
        "    using range = tbb::blocked_range<size_t>;\n"
        "\n"
        "    const auto add = [](const size_t& a, const size_t& b) {\n"
        "        return a + b;\n"
        "    };\n"
        "    const size_t morselSize = 100000;\n"
        "\n"
        "    auto start_p_1 = std::chrono::steady_clock::now();\n"
        "    // build ht for first join\n"
        "    Hashset<types::Integer, hash> ht1;\n"
        "    tbb::enumerable_thread_specific<runtime::Stack<decltype(ht1)::Entry>>\n"
        "            entries1;\n"
        "    auto found1 = tbb::parallel_reduce(\n"
        "                      range(0, cu.nrTuples, morselSize), 0,\n"
        "    [&](const tbb::blocked_range<size_t>& r, const size_t& f) {\n"
        "        auto found = f;\n"
        "        auto& entries = entries1.local();\n"
        "        for (size_t i = r.begin(), end = r.end(); i != end; ++i) {\n"
        "            if (c_mktsegment[i] == c3) {\n"
        "                entries.emplace_back(ht1.hash(c_custkey[i]), c_custkey[i]);\n"
        "                found++;\n"
        "            }\n"
        "        }\n"
        "        return found;\n"
        "    },\n"
        "    add);\n"
        "    ht1.setSize(found1);\n"
        "    parallel_insert(entries1, ht1);\n"
        "\n"
        "    auto start_p_2 = std::chrono::steady_clock::now();\n"
        "\n"
        "    // join and build second ht\n"
        "    Hashmapx<types::Integer, std::tuple<types::Date, types::Integer>, hash> ht2;\n"
        "    tbb::enumerable_thread_specific<runtime::Stack<decltype(ht2)::Entry>>\n"
        "            entries2;\n"
        "    auto found2 = tbb::parallel_reduce(\n"
        "                      range(0, ord.nrTuples, morselSize), 0,\n"
        "    [&](const tbb::blocked_range<size_t>& r, const size_t& f) {\n"
        "        auto& entries = entries2.local();\n"
        "        auto found = f;\n"
        "        for (size_t i = r.begin(), end = r.end(); i != end; ++i)\n"
        "            if (o_orderdate[i] < c1 && ht1.contains(o_custkey[i])) {\n"
        "                entries.emplace_back(\n"
        "                    ht2.hash(o_orderkey[i]), o_orderkey[i],\n"
        "                    make_tuple(o_orderdate[i], o_shippriority[i]));\n"
        "                found++;\n"
        "            }\n"
        "        return found;\n"
        "    },\n"
        "    add);\n"
        "    ht2.setSize(found2);\n"
        "    parallel_insert(entries2, ht2);\n"
        "\n"
        "    auto start_p_3 = std::chrono::steady_clock::now();\n"
        "\n"
        "    const auto one = types::Numeric<12, 2>::castString(\"1.00\");\n"
        "    const auto zero = types::Numeric<12, 4>::castString(\"0.00\");\n"
        "\n"
        "    tbb::enumerable_thread_specific<\n"
        "    Hashmapx<std::tuple<types::Integer, types::Date, types::Integer>,\n"
        "             types::Numeric<12, 4>, hash, false>>\n"
        "             groups;\n"
        "\n"
        "    auto groupOp =\n"
        "        make_GroupBy<std::tuple<types::Integer, types::Date, types::Integer>,\n"
        "        types::Numeric<12, 4>, hash>(\n"
        "    [](auto& acc, auto&& value) {\n"
        "        acc += value;\n"
        "    }, zero, nrThreads);\n"
        "\n"
        "    // preaggregation\n"
        "    tbb::parallel_for(\n"
        "        tbb::blocked_range<size_t>(0, li.nrTuples, morselSize),\n"
        "    [&](const tbb::blocked_range<size_t>& r) {\n"
        "        auto locals = groupOp.preAggLocals();\n"
        "\n"
        "        for (size_t i = r.begin(), end = r.end(); i != end; ++i) {\n"
        "            decltype(ht2)::value_type* v;\n"
        "            if (l_shipdate[i] > c2 && (v = ht2.findOne(l_orderkey[i]))) {\n"
        "                locals.consume(\n"
        "                    make_tuple(l_orderkey[i], get<0>(*v), get<1>(*v)),\n"
        "                    l_extendedprice[i] * (one - l_discount[i]));\n"
        "            }\n"
        "        }\n"
        "    });\n"
        "\n"
        "    // --- output\n"
        "    auto& result = resources.query->result;\n"
        "    auto revAttr =\n"
        "        result->addAttribute(\"revenue\", sizeof(types::Numeric<12, 4>));\n"
        "    auto orderAttr = result->addAttribute(\"l_orderkey\", sizeof(types::Integer));\n"
        "    auto dateAttr = result->addAttribute(\"o_orderdate\", sizeof(types::Date));\n"
        "    auto prioAttr =\n"
        "        result->addAttribute(\"o_shippriority\", sizeof(types::Integer));\n"
        "\n"
        "    groupOp.forallGroups([&](auto& entries) {\n"
        "        // write aggregates to result\n"
        "        auto n = entries.size();\n"
        "        auto block = result->createBlock(n);\n"
        "        auto rev = reinterpret_cast<types::Numeric<12, 4>*>(block.data(revAttr));\n"
        "        auto order = reinterpret_cast<types::Integer*>(block.data(orderAttr));\n"
        "        auto date = reinterpret_cast<types::Date*>(block.data(dateAttr));\n"
        "        auto prio = reinterpret_cast<types::Integer*>(block.data(prioAttr));\n"
        "        for (auto block : entries)\n"
        "            for (auto& entry : block) {\n"
        "                *order++ = get<0>(entry.k);\n"
        "                *date++ = get<1>(entry.k);\n"
        "                *prio++ = get<2>(entry.k);\n"
        "                *rev++ = entry.v;\n"
        "            }\n"
        "        block.addedElements(n);\n"
        "    });\n"
        "\n"
        "\n"
        "    leaveQuery(nrThreads);\n"
        "    auto q3_hyper_stop = std::chrono::steady_clock::now();\n"
        "    std::cout   << \"P1: \"\n"
        "                << std::chrono::duration_cast<std::chrono::milliseconds>(start_p_2 -\n"
        "                                                                                 start_p_1)\n"
        "                    .count()<<\",\"\n"
        "                << \"P2: \"\n"
        "                << std::chrono::duration_cast<std::chrono::milliseconds>(start_p_3 -\n"
        "                                                                         start_p_2)\n"
        "                    .count()<<\",\"\n"
        "                << \"P3: \"\n"
        "                << std::chrono::duration_cast<std::chrono::milliseconds>(q3_hyper_stop  -\n"
        "                                                                     start_p_3)\n"
        "                    .count()<<\",\"\n"
        "                << \"hyper time: \"\n"
        "                << std::chrono::duration_cast<std::chrono::milliseconds>(q3_hyper_stop -\n"
        "                      q3_hyper_start)\n"
        "                    .count()<<\",\";\n"
        "    return move(resources.query);\n"
        "}";
   f.close();

   // format code
   std::string format_command = std::string("astyle -q ") + cppName;
   system(format_command.c_str());

   return filename;
}

const std::string CodeGenerator::generatePureTyperQ6() {
   // generate code
   const std::string filename = "src/hybrid/pure_typer_q6";
   const std::string cppName = filename + ".cpp";
   std::ofstream f(cppName);
   f << "#include \"hybrid/minimal_api.hpp\"\n"
        "using namespace runtime;"
        "using namespace std;"
        "using namespace types;"
        "Relation pure_typer_q6(Database& db, size_t /*nrThreads*/) {"
        "Relation result;"
        "result.insert(\"revenue\", make_unique<algebra::Numeric>(12, 4));"
        "// --- constants\n"
        "auto c1 = types::Date::castString(\"1994-01-01\");"
        "auto c2 = types::Date::castString(\"1995-01-01\");"
        "auto c3 = types::Numeric<12, 2>::castString(\"0.05\");"
        "auto c4 = types::Numeric<12, 2>::castString(\"0.07\");"
        "auto c5 = types::Integer(24);"
        "// --- aggregates\n"
        "types::Numeric<12, 4> revenue = 0;"
        "// --- scan\n"
        "auto& rel = db[\"lineitem\"];"
        "auto l_shipdate_col = rel[\"l_shipdate\"].data<types::Date>();"
        "auto l_quantity_col = rel[\"l_quantity\"].data<types::Numeric<12, "
        "2>>();"
        "auto l_extendedprice_col ="
        "rel[\"l_extendedprice\"].data<types::Numeric<12, 2>>();"
        "auto l_discount_col = rel[\"l_discount\"].data<types::Numeric<12, "
        "2>>();"

        "revenue = tbb::parallel_reduce("
        "tbb::blocked_range<size_t>(0, rel.nrTuples), types::Numeric<12, 4>(0),"
        "[&](const tbb::blocked_range<size_t>& r,"
        "const types::Numeric<12, 4>& s) {"
        "auto revenue = s;"
        "for (size_t i = r.begin(), end = r.end(); i != end; ++i) {"
        "auto& l_shipdate = l_shipdate_col[i];"
        "auto& l_quantity = l_quantity_col[i];"
        "auto& l_extendedprice = l_extendedprice_col[i];"
        "auto& l_discount = l_discount_col[i];"
        "if ((l_shipdate >= c1) & (l_shipdate < c2) & (l_quantity < c5) &"
        "(l_discount >= c3) & (l_discount <= c4)) {"
        "// --- aggregation\n"
        "revenue += l_extendedprice * l_discount;"
        "}"
        "}"
        "return revenue;"
        "},"
        "[](const types::Numeric<12, 4>& x, const types::Numeric<12, 4>& y) {"
        "return x + y;"
        "});"
        "// --- output\n"
        "auto& rev = "
        "result[\"revenue\"].typedAccessForChange<types::Numeric<12, 4>>();"
        "rev.reset(1);"
        "rev.push_back(revenue);"
        "result.nrTuples = 1;"
        "return result;"
        "}";
   f.close();

   // format code
   std::string format_command = std::string("astyle -q ") + cppName;
   system(format_command.c_str());

   return filename;
}

const std::string CodeGenerator::generatePureTyperQ18() {
   // generate code
   const std::string filename = "src/hybrid/pure_typer_q18";
   const std::string cppName = filename + ".cpp";
   std::ofstream f(cppName);
   f << "#include \"hybrid/minimal_api.hpp\"\n"
        "using namespace runtime;\n"
        "using namespace std;\n"
        "using namespace types;\n"
        "std::unique_ptr<runtime::Query> pure_typer_q18(Database& db, size_t nrThreads) {\n"
        "    using namespace types;\n"
        "    using namespace std;\n"
        "    using hash = runtime::CRC32Hash;\n"
        "    auto resources = initQuery(nrThreads);\n"
        "\n"
        "    auto total_time = std::chrono::steady_clock::now();\n"
        "    auto& li = db[\"lineitem\"];\n"
        "    auto l_orderkey = li[\"l_orderkey\"].data<types::Integer>();\n"
        "    auto l_quantity = li[\"l_quantity\"].data<types::Numeric<12, 2>>();\n"
        "    tbb::enumerable_thread_specific<Hashmapx<types::Integer, types::Numeric<12, 2>, hash, false>>groups;\n"
        "    const auto zero = types::Numeric<12, 2>::castString(\"0.00\");\n"
        "    auto groupOp = make_GroupBy<types::Integer, types::Numeric<12, 2>, hash>([](auto& acc, auto&& value) {\n"
        "        acc += value;\n"
        "    }, zero, nrThreads);// scan lineitem and group by l_orderkey\n"
        "\n"
        "    auto p1_start = std::chrono::steady_clock::now();\n"
        "    tbb::parallel_for(tbb::blocked_range<size_t>(0, li.nrTuples, morselSize),[&](const tbb::blocked_range<size_t>& r) {\n"
        "        auto locals = groupOp.preAggLocals();\n"
        "        for (size_t i = r.begin(), end = r.end(); i != end; ++i) {\n"
        "            auto& group = locals.getGroup(l_orderkey[i]);\n"
        "//            group += l_quantity[i];//\n"
        "            locals.consume(l_orderkey[i], l_quantity[i]);\n"
        "        }\n"
        "    });\n"
        "    auto p2_start = std::chrono::steady_clock::now();\n"
        "\n"
        "    Hashset<types::Integer, hash> ht1;\n"
        "    tbb::enumerable_thread_specific<runtime::Stack<decltype(ht1)::Entry>>entries1;\n"
        "    const auto threeHundret = types::Numeric<12, 2>::castString(\"300\");\n"
        "    std::atomic<size_t> nrGroups;\n"
        "    nrGroups = 0;\n"
        "    groupOp.forallGroups([&](auto& groups) {\n"
        "        auto& entries = entries1.local();\n"
        "        size_t groupsFound = 0;\n"
        "        for (auto block : groups)for (auto& group : block)if (group.v > threeHundret) {\n"
        "                    entries.emplace_back(ht1.hash(group.k), group.k);\n"
        "                    groupsFound++;\n"
        "                }\n"
        "// TODO: reconsider this way of counting groups\n"
        "        nrGroups.fetch_add(groupsFound);\n"
        "    });\n"
        "//    std::cout<<\"nrGroups: \"<<nrGroups<<std::endl;\n"
        "    ht1.setSize(nrGroups);\n"
        "    parallel_insert(entries1, ht1);\n"
        "\n"
        "    auto p3_start = std::chrono::steady_clock::now();\n"
        "\n"
        "// build customer hashtable\n"
        "    auto& cu = db[\"customer\"];\n"
        "    auto c_custkey = cu[\"c_custkey\"].data<types::Integer>();\n"
        "    auto c_name = cu[\"c_name\"].data<types::Char<25>>();\n"
        "    Hashmapx<types::Integer, types::Char<25>, hash> ht2;\n"
        "    tbb::enumerable_thread_specific<runtime::Stack<decltype(ht2)::Entry>>entries2;\n"
        "    PARALLEL_SCAN(cu.nrTuples, entries2, {entries.emplace_back(ht2.hash(c_custkey[i]), c_custkey[i], c_name[i]);});\n"
        "    ht2.setSize(cu.nrTuples);\n"
        "    parallel_insert(entries2, ht2);\n"
        "// build last hashtable\n"
        "    Hashmapx<types::Integer,std::tuple<types::Integer, types::Date, types::Numeric<12, 2>,types::Char<25>>,hash>ht3;\n"
        "    tbb::enumerable_thread_specific<runtime::Stack<decltype(ht3)::Entry>>entries3;\n"
        "    auto& ord = db[\"orders\"];\n"
        "    auto o_orderkey = ord[\"o_orderkey\"].data<types::Integer>();\n"
        "    auto o_custkey = ord[\"o_custkey\"].data<types::Integer>();\n"
        "    auto o_orderdate = ord[\"o_orderdate\"].data<types::Date>();\n"
        "    auto o_totalprice = ord[\"o_totalprice\"].data<types::Numeric<12, 2>>();\n"
        "// scan orders\n"
        "    auto found = PARALLEL_SELECT(ord.nrTuples, entries3, {types::Char<25>* name;\n"
        "// check if it matches the order criteria and look up the customer name\n"
        "    if (ht1.contains(o_orderkey[i]) && (name = ht2.findOne(o_custkey[i]))) {\n"
        "    entries.emplace_back(ht3.hash(o_orderkey[i]), o_orderkey[i],make_tuple(o_custkey[i], o_orderdate[i], o_totalprice[i], *name));\n"
        "        found++;\n"
        "    }\n"
        "                                                         });\n"
        "    ht3.setSize(found);\n"
        "    parallel_insert(entries3, ht3);\n"
        "\n"
        "    auto p4_start = std::chrono::steady_clock::now();\n"
        "\n"
        "    auto finalGroupOp = make_GroupBy<std::tuple<types::Integer, types::Date, types::Numeric<12, 2>,types::Char<25>, types::Integer>,types::Numeric<12, 2>, hash>([](auto& acc, auto&& value) {\n"
        "        acc += value;\n"
        "    }, zero, nrThreads);\n"
        "// scan lineitem and group by l_orderkey\n"
        "    tbb::parallel_for(tbb::blocked_range<size_t>(0, li.nrTuples, morselSize),[&](const tbb::blocked_range<size_t>& r) {\n"
        "        auto locals = finalGroupOp.preAggLocals();\n"
        "        for (size_t i = r.begin(), end = r.end(); i != end; ++i) {\n"
        "            std::tuple<types::Integer, types::Date, types::Numeric<12, 2>,types::Char<25>>* v;\n"
        "            if ((v = ht3.findOne(l_orderkey[i]))) {\n"
        "                auto& group =locals.getGroup(tuple_cat(*v, make_tuple(l_orderkey[i])));\n"
        "                group += l_quantity[i];\n"
        "            }\n"
        "        }\n"
        "    });\n"
        "    auto& result = resources.query->result;\n"
        "    auto namAttr = result->addAttribute(\"c_name\", sizeof(types::Char<25>));\n"
        "    auto ckyAttr = result->addAttribute(\"c_custkey\", sizeof(types::Integer));\n"
        "    auto okyAttr = result->addAttribute(\"o_orderkey\", sizeof(types::Integer));\n"
        "    auto datAttr = result->addAttribute(\"o_orderdate\", sizeof(types::Date));\n"
        "    auto totAttr =result->addAttribute(\"o_totalprice\", sizeof(types::Numeric<12, 2>));\n"
        "    auto sumAttr = result->addAttribute(\"sum\", sizeof(types::Numeric<12, 2>));\n"
        "    finalGroupOp.forallGroups([&](auto& groups) {\n"
        "// write aggregates to result\n"
        "        auto n = groups.size();\n"
        "        auto block = result->createBlock(n);\n"
        "        auto name = reinterpret_cast<types::Char<25>*>(block.data(namAttr));\n"
        "        auto cky = reinterpret_cast<types::Integer*>(block.data(ckyAttr));\n"
        "        auto oky = reinterpret_cast<types::Integer*>(block.data(okyAttr));\n"
        "        auto dat = reinterpret_cast<types::Date*>(block.data(datAttr));\n"
        "        auto tot = reinterpret_cast<types::Numeric<12, 2>*>(block.data(totAttr));\n"
        "        auto sum = reinterpret_cast<types::Numeric<12, 2>*>(block.data(sumAttr));\n"
        "        for (auto block : groups)for (auto& group : block) {\n"
        "                auto& k = group.k;\n"
        "                *name++ = std::get<3>(k);\n"
        "                *cky++ = get<0>(k);\n"
        "                *oky++ = get<4>(k);\n"
        "                *dat++ = get<1>(k);\n"
        "                *tot++ = get<2>(k);\n"
        "                *sum++ = group.v;\n"
        "            }\n"
        "        block.addedElements(n);\n"
        "    });\n"
        "\n"
        "    auto total_time_end = std::chrono::steady_clock::now();\n"
        "    std::cout\n"
        "            << \"P1: \"\n"
        "            << std::chrono::duration_cast<std::chrono::milliseconds>(p2_start - p1_start)\n"
        "                    .count()<<\",\"\n"
        "            << \"P2: \"\n"
        "            << std::chrono::duration_cast<std::chrono::milliseconds>(p3_start - p2_start)\n"
        "                    .count()<<\",\"\n"
        "            << \"P3: \"\n"
        "            << std::chrono::duration_cast<std::chrono::milliseconds>(p4_start - p3_start)\n"
        "                    .count()<<\",\"\n"
        "            << \"P4: \"\n"
        "            << std::chrono::duration_cast<std::chrono::milliseconds>(total_time_end -\n"
        "                                                                     p4_start)\n"
        "                    .count()<<\",\"\n"
        "            << \"Total time \"\n"
        "            << std::chrono::duration_cast<std::chrono::milliseconds>(\n"
        "                    total_time_end  - total_time)\n"
        "                    .count()\n"
        "            << \" milliseconds.\" << std::endl;\n"
        "\n"
        "    leaveQuery(nrThreads);\n"
        "    return move(resources.query);\n"
        "}";
   f.close();

   // format code
   std::string format_command = std::string("astyle -q ") + cppName;
   system(format_command.c_str());

   return filename;
}

const std::string CodeGenerator::generateHybridTyperQ1() {
   // generate code
   const std::string filename = "src/hybrid/hybrid_typer_q1";
   const std::string cppName = filename + ".cpp";
   std::ofstream f(cppName);
   f << "/*\n"
 " * Parallel version -updated\n"
 " */\n"
 "\n"
 "#include \"hybrid/minimal_api.hpp\"\n"
 "using namespace runtime;\n"
 "using namespace std;\n"
 "using namespace types;\n"
 "std::unique_ptr<runtime::Query> hybrid_typer_q1(Database& db, size_t nrThreads, size_t firstTuple, std::unordered_map<std::thread::id, runtime::PartitionedDeque<1024>>&twThreadData) {\n"
 "\n"
 "// prepare query data\n"
 "    types::Date c1 = types::Date::castString(\"1998-09-02\");\n"
 "    types::Numeric<12, 2> one = types::Numeric<12, 2>::castString(\"1.00\");\n"
 "    auto& li = db[\"lineitem\"];\n"
 "    auto l_returnflag = li[\"l_returnflag\"].data<types::Char<1>>();\n"
 "    auto l_linestatus = li[\"l_linestatus\"].data<types::Char<1>>();\n"
 "    auto l_extendedprice = li[\"l_extendedprice\"].data<types::Numeric<12, 2>>();\n"
 "    auto l_discount = li[\"l_discount\"].data<types::Numeric<12, 2>>();\n"
 "    auto l_tax = li[\"l_tax\"].data<types::Numeric<12, 2>>();\n"
 "    auto l_quantity = li[\"l_quantity\"].data<types::Numeric<12, 2>>();\n"
 "    auto l_shipdate = li[\"l_shipdate\"].data<types::Date>();\n"
 "\n"
 "// setup parallel execution + prepare result\n"
 "    auto resources = initQuery(nrThreads);\n"
 "    using hash = runtime::CRC32Hash;\n"
 "\n"
 "// define the aggregation\n"
 "    auto groupOp = make_GroupBy<tuple<Char<1>, Char<1>>,tuple<Numeric<12, 2>, Numeric<12, 2>,Numeric<12, 4>, Numeric<12, 6>, int64_t>,hash>([](auto& acc, auto&& value) {\n"
 "        get<0>(acc) += get<0>(value);\n"
 "        get<1>(acc) += get<1>(value);\n"
 "        get<2>(acc) += get<2>(value);\n"
 "        get<3>(acc) += get<3>(value);\n"
 "        get<4>(acc) += get<4>(value);\n"
 "    },make_tuple(Numeric<12, 2>(), Numeric<12, 2>(), Numeric<12, 4>(),Numeric<12, 6>(), int64_t(0)),nrThreads);\n"
 "\n"
 "// compute typer's partial thread-local hash tables\n"
 "    tbb::parallel_for(tbb::blocked_range<size_t>(firstTuple, li.nrTuples, morselSize),[&](const tbb::blocked_range<size_t>& r) {\n"
 "        auto locals = groupOp.preAggLocals();\n"
 "        for (size_t i = r.begin(), end = r.end(); i != end; ++i) {\n"
 "            if (l_shipdate[i] <= c1) {\n"
 "                auto& group =locals.getGroup(make_tuple(l_returnflag[i], l_linestatus[i]));\n"
 "                get<0>(group) += l_quantity[i];\n"
 "                get<1>(group) += l_extendedprice[i];\n"
 "                auto disc_price = l_extendedprice[i] * (one - l_discount[i]);\n"
 "                get<2>(group) += disc_price;\n"
 "                auto charge = disc_price * (one + l_tax[i]);\n"
 "                get<3>(group) += charge;\n"
 "                get<4>(group) += 1;\n"
 "            }\n"
 "        }\n"
 "    });\n"
 "\n"
 "// merge tw's partial thread-local hash tables with typer's partial thread-local hash tables\n"
 "    tbb::parallel_for_each(twThreadData.begin(), twThreadData.end(), [&](auto& threadPartitions) {\n"
 "        auto locals = groupOp.preAggLocals();\n"
 "        for(auto partition = threadPartitions.second.getPartitions().begin(); partition !=threadPartitions.second.getPartitions().end(); partition++ ) {\n"
 "            for (auto chunk = partition->first; chunk; chunk = chunk->next) {\n"
 "                auto elementSize = threadPartitions.second.entrySize;\n"
 "                auto nPart = partition->size(chunk, elementSize);\n"
 "                auto data = chunk->template data<hybrid::Q1TectorTuple>();\n"
 "                for (unsigned i = 0; i < nPart; ++i) {\n"
 "                    hybrid::Q1TectorTuple t =data[i];\n"
 "                    hybrid::Q1TyperKey key =std::make_tuple(types::Char<1>::build(t.returnflag),types::Char<1>::build(t.linestatus));\n"
 "                    hybrid::Q1TyperValue value = std::make_tuple(types::Numeric<12, 2>(t.sum_qty),types::Numeric<12, 2>(t.sum_base_price),types::Numeric<12, 4>(t.sum_disc_price),types::Numeric<12, 6>(t.sum_charge), t.count_order);\n"
 "                    locals.consume(key, value);\n"
 "                }\n"
 "            }\n"
 "        }\n"
 "    });\n"
 "\n"
 "// materialize final result\n"
 "    auto& result = resources.query->result;\n"
 "    auto retAttr = result->addAttribute(\"l_returnflag\", sizeof(Char<1>));\n"
 "    auto statusAttr = result->addAttribute(\"l_linestatus\", sizeof(Char<1>));\n"
 "    auto qtyAttr = result->addAttribute(\"sum_qty\", sizeof(Numeric<12, 2>));\n"
 "    auto base_priceAttr = result->addAttribute(\"sum_base_price\", sizeof(Numeric<12, 2>));\n"
 "    auto disc_priceAttr = result->addAttribute(\"sum_disc_price\", sizeof(Numeric<12, 2>));\n"
 "    auto chargeAttr = result->addAttribute(\"sum_charge\", sizeof(Numeric<12, 2>));\n"
 "    auto count_orderAttr = result->addAttribute(\"count_order\", sizeof(int64_t));\n"
 "    groupOp.forallGroups([&](runtime::Stack<decltype(groupOp)::group_t>& /*auto&*/ entries) {\n"
 "        auto n = entries.size();\n"
 "        auto block = result->createBlock(n);\n"
 "        auto ret = reinterpret_cast<Char<1>*>(block.data(retAttr));\n"
 "        auto status = reinterpret_cast<Char<1>*>(block.data(statusAttr));\n"
 "        auto qty = reinterpret_cast<Numeric<12, 2>*>(block.data(qtyAttr));\n"
 "        auto base_price = reinterpret_cast<Numeric<12, 2>*>(block.data(base_priceAttr));\n"
 "        auto disc_price = reinterpret_cast<Numeric<12, 4>*>(block.data(disc_priceAttr));\n"
 "        auto charge = reinterpret_cast<Numeric<12, 6>*>(block.data(chargeAttr));\n"
 "        auto count_order = reinterpret_cast<int64_t*>(block.data(count_orderAttr));\n"
 "        for (auto block : entries)for (auto& entry : block) {\n"
 "                *ret++ = get<0>(entry.k);\n"
 "                *status++ = get<1>(entry.k);\n"
 "                *qty++ = get<0>(entry.v);\n"
 "                *base_price++ = get<1>(entry.v);\n"
 "                *disc_price++ = get<2>(entry.v);\n"
 "                *charge++ = get<3>(entry.v);\n"
 "                *count_order++ = get<4>(entry.v);\n"
 "            }\n"
 "        block.addedElements(n);\n"
 "    });\n"
 "\n"
 "// join threads\n"
 "    leaveQuery(nrThreads);\n"
 "    return move(resources.query);\n"
 "}";
   f.close();

   // format code
   std::string format_command = std::string("astyle -q ") + cppName;
   system(format_command.c_str());

   return filename;
}


//const std::string CodeGenerator::generateHybridTyperQ1() {
//   // generate code
//   const std::string filename = "src/hybrid/hybrid_typer_q1";
//   const std::string cppName = filename + ".cpp";
//   std::ofstream f(cppName);
//   f << "/*\n"
// " * Parallel version -in use\n"
// " */\n"
// "\n"
// "#include \"hybrid/minimal_api.hpp\"\n"
// "using namespace runtime;\n"
// "using namespace std;\n"
// "using namespace types;\n"
// "std::unique_ptr<runtime::Query> hybrid_typer_q1(Database& db, size_t nrThreads, size_t firstTuple, std::unordered_map<std::thread::id, runtime::PartitionedDeque<1024>>&twThreadData) {\n"
// "\n"
// "// prepare query data\n"
// "    types::Date c1 = types::Date::castString(\"1998-09-02\");\n"
// "    types::Numeric<12, 2> one = types::Numeric<12, 2>::castString(\"1.00\");\n"
// "    auto& li = db[\"lineitem\"];\n"
// "    auto l_returnflag = li[\"l_returnflag\"].data<types::Char<1>>();\n"
// "    auto l_linestatus = li[\"l_linestatus\"].data<types::Char<1>>();\n"
// "    auto l_extendedprice = li[\"l_extendedprice\"].data<types::Numeric<12, 2>>();\n"
// "    auto l_discount = li[\"l_discount\"].data<types::Numeric<12, 2>>();\n"
// "    auto l_tax = li[\"l_tax\"].data<types::Numeric<12, 2>>();\n"
// "    auto l_quantity = li[\"l_quantity\"].data<types::Numeric<12, 2>>();\n"
// "    auto l_shipdate = li[\"l_shipdate\"].data<types::Date>();\n"
// "\n"
// "// setup parallel execution + prepare result\n"
// "    auto resources = initQuery(nrThreads);\n"
// "    using hash = runtime::CRC32Hash;\n"
// "\n"
// "// define the aggregation\n"
// "    auto groupOp = make_GroupBy<tuple<Char<1>, Char<1>>,tuple<Numeric<12, 2>, Numeric<12, 2>,Numeric<12, 4>, Numeric<12, 6>, int64_t>,hash>([](auto& acc, auto&& value) {\n"
// "        get<0>(acc) += get<0>(value);\n"
// "        get<1>(acc) += get<1>(value);\n"
// "        get<2>(acc) += get<2>(value);\n"
// "        get<3>(acc) += get<3>(value);\n"
// "        get<4>(acc) += get<4>(value);\n"
// "    },make_tuple(Numeric<12, 2>(), Numeric<12, 2>(), Numeric<12, 4>(),Numeric<12, 6>(), int64_t(0)),nrThreads);\n"
// "\n"
// "// compute typer's partial thread-local hash tables\n"
// "    tbb::parallel_for(tbb::blocked_range<size_t>(firstTuple, li.nrTuples, morselSize),[&](const tbb::blocked_range<size_t>& r) {\n"
// "        auto locals = groupOp.preAggLocals();\n"
// "        for (size_t i = r.begin(), end = r.end(); i != end; ++i) {\n"
// "            if (l_shipdate[i] <= c1) {\n"
// "                auto& group =locals.getGroup(make_tuple(l_returnflag[i], l_linestatus[i]));\n"
// "                get<0>(group) += l_quantity[i];\n"
// "                get<1>(group) += l_extendedprice[i];\n"
// "                auto disc_price = l_extendedprice[i] * (one - l_discount[i]);\n"
// "                get<2>(group) += disc_price;\n"
// "                auto charge = disc_price * (one + l_tax[i]);\n"
// "                get<3>(group) += charge;\n"
// "                get<4>(group) += 1;\n"
// "            }\n"
// "        }\n"
// "    });\n"
// "\n"
// "// merge tw's partial thread-local hash tables with typer's partial thread-local hash tables\n"
// "    tbb::parallel_for_each(twThreadData.begin(), twThreadData.end(), [&](auto& threadPartitions) {\n"
// "        auto locals = groupOp.preAggLocals();\n"
// "        tbb::parallel_for_each(threadPartitions.second.getPartitions().begin(),threadPartitions.second.getPartitions().end(), [&](auto& partition) {\n"
// "            for (auto chunk = partition.first; chunk; chunk = chunk->next) {\n"
// "                auto elementSize = threadPartitions.second.entrySize;\n"
// "                auto nPart = partition.size(chunk, elementSize);\n"
// "                auto data = chunk->template data<hybrid::Q1TectorTuple>();\n"
// "                for (unsigned i = 0; i < nPart; ++i) {\n"
// "                    hybrid::Q1TectorTuple t =data[i];\n"
// "                    hybrid::Q1TyperKey key =std::make_tuple(types::Char<1>::build(t.returnflag),types::Char<1>::build(t.linestatus));\n"
// "                    hybrid::Q1TyperValue value = std::make_tuple(types::Numeric<12, 2>(t.sum_qty),types::Numeric<12, 2>(t.sum_base_price),types::Numeric<12, 4>(t.sum_disc_price),types::Numeric<12, 6>(t.sum_charge), t.count_order);\n"
// "                    locals.consume(key, value);\n"
// "                }\n"
// "            }\n"
// "        });\n"
// "    });\n"
// "\n"
// "// materialize final result\n"
// "    auto& result = resources.query->result;\n"
// "    auto retAttr = result->addAttribute(\"l_returnflag\", sizeof(Char<1>));\n"
// "    auto statusAttr = result->addAttribute(\"l_linestatus\", sizeof(Char<1>));\n"
// "    auto qtyAttr = result->addAttribute(\"sum_qty\", sizeof(Numeric<12, 2>));\n"
// "    auto base_priceAttr = result->addAttribute(\"sum_base_price\", sizeof(Numeric<12, 2>));\n"
// "    auto disc_priceAttr = result->addAttribute(\"sum_disc_price\", sizeof(Numeric<12, 2>));\n"
// "    auto chargeAttr = result->addAttribute(\"sum_charge\", sizeof(Numeric<12, 2>));\n"
// "    auto count_orderAttr = result->addAttribute(\"count_order\", sizeof(int64_t));\n"
// "    groupOp.forallGroups([&](runtime::Stack<decltype(groupOp)::group_t>& /*auto&*/ entries) {\n"
// "        auto n = entries.size();\n"
// "        auto block = result->createBlock(n);\n"
// "        auto ret = reinterpret_cast<Char<1>*>(block.data(retAttr));\n"
// "        auto status = reinterpret_cast<Char<1>*>(block.data(statusAttr));\n"
// "        auto qty = reinterpret_cast<Numeric<12, 2>*>(block.data(qtyAttr));\n"
// "        auto base_price = reinterpret_cast<Numeric<12, 2>*>(block.data(base_priceAttr));\n"
// "        auto disc_price = reinterpret_cast<Numeric<12, 4>*>(block.data(disc_priceAttr));\n"
// "        auto charge = reinterpret_cast<Numeric<12, 6>*>(block.data(chargeAttr));\n"
// "        auto count_order = reinterpret_cast<int64_t*>(block.data(count_orderAttr));\n"
// "        for (auto block : entries)for (auto& entry : block) {\n"
// "                *ret++ = get<0>(entry.k);\n"
// "                *status++ = get<1>(entry.k);\n"
// "                *qty++ = get<0>(entry.v);\n"
// "                *base_price++ = get<1>(entry.v);\n"
// "                *disc_price++ = get<2>(entry.v);\n"
// "                *charge++ = get<3>(entry.v);\n"
// "                *count_order++ = get<4>(entry.v);\n"
// "            }\n"
// "        block.addedElements(n);\n"
// "    });\n"
// "\n"
// "// join threads\n"
// "    leaveQuery(nrThreads);\n"
// "    return move(resources.query);\n"
// "}";
//   f.close();
//
//   // format code
//   std::string format_command = std::string("astyle -q ") + cppName;
//   system(format_command.c_str());
//
//   return filename;
//}


const std::string CodeGenerator::generateHybridPartialTyperQ1() {
   // generate code
   const std::string filename = "src/hybrid/hybrid_partial_typer_q1";
   const std::string cppName = filename + ".cpp";
   std::ofstream f(cppName);
   f << "#include \"hybrid/minimal_api.hpp\"\n"
        "using namespace runtime;\n"
        "using namespace std;\n"
        "using namespace types;\n"
        "std::unique_ptr<runtime::Query> hybrid_partial_typer_q1(Database& db, size_t nrThreads, size_t firstTuple) {\n"
        "\n"
        "    auto q1_hyper_start = std::chrono::steady_clock::now();\n"
        "\n"
        "    using namespace types;\n"
        "    using namespace std;\n"
        "    types::Date c1 = types::Date::castString(\"1998-09-02\");\n"
        "    types::Numeric<12, 2> one = types::Numeric<12, 2>::castString(\"1.00\");\n"
        "    auto& li = db[\"lineitem\"];\n"
        "    auto l_returnflag = li[\"l_returnflag\"].data<types::Char<1>>();\n"
        "    auto l_linestatus = li[\"l_linestatus\"].data<types::Char<1>>();\n"
        "    auto l_extendedprice = li[\"l_extendedprice\"].data<types::Numeric<12, 2>>();\n"
        "    auto l_discount = li[\"l_discount\"].data<types::Numeric<12, 2>>();\n"
        "    auto l_tax = li[\"l_tax\"].data<types::Numeric<12, 2>>();\n"
        "    auto l_quantity = li[\"l_quantity\"].data<types::Numeric<12, 2>>();\n"
        "    auto l_shipdate = li[\"l_shipdate\"].data<types::Date>();\n"
        "\n"
        "    auto resources = initQuery(nrThreads);\n"
        "\n"
        "    using hash = runtime::CRC32Hash;\n"
        "\n"
        "    auto groupOp = make_GroupBy<tuple<Char<1>, Char<1>>,\n"
        "            tuple<Numeric<12, 2>, Numeric<12, 2>,\n"
        "                    Numeric<12, 4>, Numeric<12, 6>, int64_t>,\n"
        "            hash>(\n"
        "            [](auto& acc, auto&& value) {\n"
        "                get<0>(acc) += get<0>(value);\n"
        "                get<1>(acc) += get<1>(value);\n"
        "                get<2>(acc) += get<2>(value);\n"
        "                get<3>(acc) += get<3>(value);\n"
        "                get<4>(acc) += get<4>(value);\n"
        "            },\n"
        "            make_tuple(Numeric<12, 2>(), Numeric<12, 2>(), Numeric<12, 4>(),\n"
        "                       Numeric<12, 6>(), int64_t(0)),\n"
        "            nrThreads);\n"
        "\n"
        "    tbb::parallel_for(\n"
        "            tbb::blocked_range<size_t>(firstTuple, li.nrTuples, morselSize),\n"
        "            [&](const tbb::blocked_range<size_t>& r) {\n"
        "                auto locals = groupOp.preAggLocals();\n"
        "                for (size_t i = r.begin(), end = r.end(); i != end; ++i) {\n"
        "                    if (l_shipdate[i] <= c1) {\n"
        "                        auto& group = locals.getGroup(\n"
        "                                make_tuple(l_returnflag[i], l_linestatus[i]));\n"
        "\n"
        "                        get<0>(group) += l_quantity[i];\n"
        "                        get<1>(group) += l_extendedprice[i];\n"
        "                        auto disc_price = l_extendedprice[i] * (one - l_discount[i]);\n"
        "                        get<2>(group) += disc_price;\n"
        "                        auto charge = disc_price * (one + l_tax[i]);\n"
        "                        get<3>(group) += charge;\n"
        "                        get<4>(group) += 1;\n"
        "                    }\n"
        "                }\n"
        "            });\n"
        "\n"
        "    auto& result = resources.query->result;\n"
        "    auto retAttr = result->addAttribute(\"l_returnflag\", sizeof(Char<1>));\n"
        "    auto statusAttr = result->addAttribute(\"l_linestatus\", sizeof(Char<1>));\n"
        "    auto qtyAttr = result->addAttribute(\"sum_qty\", sizeof(Numeric<12, 2>));\n"
        "    auto base_priceAttr =\n"
        "            result->addAttribute(\"sum_base_price\", sizeof(Numeric<12, 2>));\n"
        "    auto disc_priceAttr =\n"
        "            result->addAttribute(\"sum_disc_price\", sizeof(Numeric<12, 2>));\n"
        "    auto chargeAttr = result->addAttribute(\"sum_charge\", sizeof(Numeric<12, 2>));\n"
        "    auto count_orderAttr = result->addAttribute(\"count_order\", sizeof(int64_t));\n"
        "\n"
        "\n"
        "    groupOp.forallGroups(\n"
        "            [&](runtime::Stack<decltype(groupOp)::group_t>& /*auto&*/ entries) {\n"
        "                auto n = entries.size();\n"
        "                auto block = result->createBlock(n);\n"
        "                auto ret = reinterpret_cast<Char<1>*>(block.data(retAttr));\n"
        "                auto status = reinterpret_cast<Char<1>*>(block.data(statusAttr));\n"
        "                auto qty = reinterpret_cast<Numeric<12, 2>*>(block.data(qtyAttr));\n"
        "                auto base_price =\n"
        "                        reinterpret_cast<Numeric<12, 2>*>(block.data(base_priceAttr));\n"
        "                auto disc_price =\n"
        "                        reinterpret_cast<Numeric<12, 4>*>(block.data(disc_priceAttr));\n"
        "                auto charge =\n"
        "                        reinterpret_cast<Numeric<12, 6>*>(block.data(chargeAttr));\n"
        "                auto count_order =\n"
        "                        reinterpret_cast<int64_t*>(block.data(count_orderAttr));\n"
        "                for (auto block : entries)\n"
        "                    for (auto& entry : block) {\n"
        "                        *ret++ = get<0>(entry.k);\n"
        "                        *status++ = get<1>(entry.k);\n"
        "                        *qty++ = get<0>(entry.v);\n"
        "                        *base_price++ = get<1>(entry.v);\n"
        "                        *disc_price++ = get<2>(entry.v);\n"
        "                        *charge++ = get<3>(entry.v);\n"
        "                        *count_order++ = get<4>(entry.v);\n"
        "                    }\n"
        "                block.addedElements(n);\n"
        "            });\n"
        "\n"
        "\n"
        "    leaveQuery(nrThreads);\n"
        "\n"
        "    auto q1_hyper_stop = std::chrono::steady_clock::now();\n"
        "    std::cout << \"hyper time: \"\n"
        "              << std::chrono::duration_cast<std::chrono::milliseconds>(q1_hyper_stop -\n"
        "                                                                       q1_hyper_start)\n"
        "                      .count()<<std::endl;\n"
        "\n"
        "    return move(resources.query);\n"
        "}";
   f.close();

   // format code
   std::string format_command = std::string("astyle -q ") + cppName;
   system(format_command.c_str());

   return filename;
}

const std::string CodeGenerator::generateHybridTyperQ6() {
   // generate code
   const std::string filename = "src/hybrid/hybrid_typer_q6";
   const std::string cppName = filename + ".cpp";
   std::ofstream f(cppName);
   f << "#include \"hybrid/minimal_api.hpp\"\n"
        "using namespace runtime;\n"
        "using namespace std;\n"
        "Relation hybrid_typer_q6(Database& db, size_t nrThreads, size_t firstTuple, size_t columnID, int64_t* twRevenue) {\n"
        "\n"
        "    Relation result;\n"
        "    result.insert(\"revenue\", make_unique<algebra::Numeric>(12,4));\n"
        "    auto c1 = types::Date::castString(\"1994-01-01\");\n"
        "    auto c2 = types::Date::castString(\"1995-01-01\");\n"
        "    auto c3 = types::Numeric<12, 2>::castString(\"0.05\");\n"
        "    auto c4 = types::Numeric<12, 2>::castString(\"0.07\");\n"
        "    auto c5 = types::Integer(24);\n"
        "\n"
        "    auto& rel = db[\"lineitem\"];\n"
        "    auto l_shipdate_col = rel[\"l_shipdate\"].data<types::Date>();\n"
        "    auto l_quantity_col = rel[\"l_quantity\"].data<types::Numeric<12, 2>>();\n"
        "    auto l_extendedprice_col = rel[\"l_extendedprice\"].data<types::Numeric<12,2 >>();\n"
        "    auto l_discount_col = rel[\"l_discount\"].data<types::Numeric<12,2>>();\n"
        "\n"
        "    types::Numeric<12, 4> revenue(twRevenue[columnID]);//initialize the aggregates with partial results from vectorized execution\n"
        "\n"
        "    //In case all the values are processed in vectorized execution itself\n"
        "    if(firstTuple == rel.nrTuples) {\n"
        "        auto& rev = result[\"revenue\"].typedAccessForChange<types::Numeric<12,4>>();\n"
        "        rev.reset(1);\n"
        "        rev.push_back(revenue);\n"
        "        result.nrTuples = 1;\n"
        "        return result;\n"
        "    }\n"
        "\n"
        "    revenue += tbb::parallel_reduce(\n"
        "                   tbb::blocked_range<size_t>(firstTuple, rel.nrTuples),\n"
        "                   types::Numeric<12, 4>(0),\n"
        "                   [&](const tbb::blocked_range<size_t>& r,\n"
        "    const types::Numeric<12, 4>& s) {\n"
        "        auto revenue = s;\n"
        "        for (size_t i = r.begin(), end = r.end(); i != end; ++i) {\n"
        "            auto& l_shipdate = l_shipdate_col[i];\n"
        "            auto& l_quantity = l_quantity_col[i];\n"
        "            auto& l_extendedprice = l_extendedprice_col[i];\n"
        "            auto& l_discount = l_discount_col[i];\n"
        "            if ((l_shipdate >= c1) & (l_shipdate < c2) & (l_quantity < c5) &\n"
        "                    (l_discount >= c3) & (l_discount <= c4)) {\n"
        "                revenue += l_extendedprice * l_discount;\n"
        "            }\n"
        "        }\n"
        "        return revenue;\n"
        "    },\n"
        "    [](const types::Numeric<12, 4>& x, const types::Numeric<12, 4>& y) {\n"
        "        return x + y;\n"
        "    });\n"
        "    auto& rev = result[\"revenue\"].typedAccessForChange<types::Numeric<12,4>>();\n"
        "    rev.reset(1);\n"
        "    rev.push_back(revenue);\n"
        "    result.nrTuples = 1;\n"
        "    return result;\n"
        "}";

//   f << "#include \"hybrid/minimal_api.hpp\"\n";
//   f << "using namespace runtime;\n";
//   f << "using namespace std;\n";
//   f << "Relation hybrid_typer_q6(Database& db, size_t nrThreads, size_t "
//        "firstTuple, int64_t twRevenue) {\n";
//   f << "Relation result;\n";
//   f << "result.insert(\"revenue\", make_unique<algebra::Numeric>(12,4));\n";
//   f << "auto c1 = types::Date::castString(\"1994-01-01\");\n";
//   f << "auto c2 = types::Date::castString(\"1995-01-01\");\n";
//   f << "auto c3 = types::Numeric<12, 2>::castString(\"0.05\");\n";
//   f << "auto c4 = types::Numeric<12, 2>::castString(\"0.07\");\n";
//   f << "auto c5 = types::Integer(24);\n";
//   f << "types::Numeric<12, 4> revenue(twRevenue);\n";
//   f << "auto& rel = db[\"lineitem\"];\n";
//   f << "auto l_shipdate_col = rel[\"l_shipdate\"].data<types::Date>();\n";
//   f << "auto l_quantity_col = rel[\"l_quantity\"].data<types::Numeric<12, "
//        "2>>();\n";
//   f << "auto l_extendedprice_col = "
//        "rel[\"l_extendedprice\"].data<types::Numeric<12,2 >>();\n";
//   f << "auto l_discount_col = rel[\"l_discount\"].data<types::Numeric<12,"
//        "2>>();\n";
//   f << "revenue += tbb::parallel_reduce(\n";
//   f << "tbb::blocked_range<size_t>(firstTuple, rel.nrTuples),\n";
//   f << "types::Numeric<12, 4>(0),\n";
//   f << "[&](const tbb::blocked_range<size_t>& r,\n";
//   f << "const types::Numeric<12, 4>& s) {\n";
//   f << "auto revenue = s;\n";
//   f << "for (size_t i = r.begin(), end = r.end(); i != end; ++i) {\n";
//   f << "auto& l_shipdate = l_shipdate_col[i];\n";
//   f << "auto& l_quantity = l_quantity_col[i];\n";
//   f << "auto& l_extendedprice = l_extendedprice_col[i];\n";
//   f << "auto& l_discount = l_discount_col[i];\n";
//   f << "if ((l_shipdate >= c1) & (l_shipdate < c2) & (l_quantity < c5) &\n";
//   f << "(l_discount >= c3) & (l_discount <= c4)) {\n";
//   f << "revenue += l_extendedprice * l_discount;\n";
//   f << "}\n";
//   f << "}\n";
//   f << "return revenue;\n";
//   f << "},\n";
//   f << "[](const types::Numeric<12, 4>& x, const types::Numeric<12, 4>& y) "
//        "{\n";
//   f << "return x + y;\n";
//   f << "});\n";
//   f << "auto& rev = "
//        "result[\"revenue\"].typedAccessForChange<types::Numeric<12,4>>();"
//        "\n";
//   f << "rev.reset(1);\n";
//   f << "rev.push_back(revenue);\n";
//   f << "result.nrTuples = 1;\n";
//   f << "return result;\n";
//   f << "}\n";
   f.close();

   // format code
   std::string format_command = std::string("astyle -q ") + cppName;
   system(format_command.c_str());

   return filename;
}

const std::string CodeGenerator::generateHybridTyperQ18() {
   // generate code
   const std::string filename = "src/hybrid/hybrid_typer_q18";
   const std::string cppName = filename + ".cpp";
   std::ofstream f(cppName);
   f << "/**\n"
        " * parallel version - Q18\n"
        " */\n"
        "\n"
        "#include \"hybrid/minimal_api.hpp\"\n"
        "using namespace runtime;\n"
        "using namespace std;\n"
        "using namespace types;\n"
        "std::unique_ptr<runtime::Query> hybrid_typer_q18(Database & db, size_t nrThreads, runtime::Hashmap & twCustomerHT,std::unordered_map<std::thread::id, runtime::PartitionedDeque<1024>>& twAggrRes, size_t firstTuple) {\n"
        "\n"
        "    auto total_time = std::chrono::steady_clock::now();\n"
        "    auto q3_hyper_start = std::chrono::steady_clock::now();\n"
        "    using namespace types;\n"
        "    using namespace std;\n"
        "    using hash = runtime::CRC32Hash;\n"
        "    auto resources = initQuery(nrThreads);\n"
        "    auto& li = db[\"lineitem\"];\n"
        "    auto l_orderkey = li[\"l_orderkey\"].data<types::Integer>();\n"
        "    auto l_quantity = li[\"l_quantity\"].data<types::Numeric<12, 2>>();\n"
        "    tbb::enumerable_thread_specific<Hashmapx<types::Integer, types::Numeric<12, 2>, hash, false>>groups;\n"
        "    const auto zero = types::Numeric<12, 2>::castString(\"0.00\");\n"
        "    auto groupOp = make_GroupBy<types::Integer, types::Numeric<12, 2>, hash>([](auto& acc, auto&& value) {\n"
        "        acc += value;\n"
        "    }, zero, nrThreads);\n"
        "\n"
        "    auto p1_start = std::chrono::steady_clock::now();\n"
        "\n"
        "    auto p2_start = std::chrono::steady_clock::now();\n"
        "\n"
        "    // scan lineitem and group by l_orderkey\n"
        "    tbb::parallel_for_each(twAggrRes.begin(), twAggrRes.end(), [&](auto& threadPartitions) {\n"
        "        auto locals = groupOp.preAggLocals();\n"
        "        for(auto partition = threadPartitions.second.getPartitions().begin(); partition !=threadPartitions.second.getPartitions().end(); partition++ ) {\n"
        "            for (auto chunk = partition->first; chunk; chunk = chunk->next) {\n"
        "                auto elementSize = threadPartitions.second.entrySize;\n"
        "                auto nPart = partition->size(chunk, elementSize);\n"
        "                auto data =chunk->template data<hybrid::Q18TWAggrTuple>();\n"
        "                for (unsigned i = 0; i < nPart; ++i) {\n"
        "                    hybrid::Q18TWAggrTuple t = data[i];\n"
        "                    types::Integer key = types::Integer(t.l_orderkey);\n"
        "                    types::Numeric<12, 2> value =types::Numeric<12, 2>(t.l_quantity);\n"
        "                    auto& group = locals.getGroup(key);\n"
        "                    locals.consume(key, value);\n"
        "                }\n"
        "            }\n"
        "        }\n"
        "    });\n"
        "\n"
        "    auto p3_start = std::chrono::steady_clock::now();\n"
        "\n"
        "    Hashset<types::Integer, hash> ht1;\n"
        "    tbb::enumerable_thread_specific<runtime::Stack<decltype(ht1)::Entry>>entries1;\n"
        "    const auto threeHundret = types::Numeric<12, 2>::castString(\"300\");\n"
        "    std::atomic<size_t> nrGroups;\n"
        "    nrGroups = 0;\n"
        "\n"
        "    groupOp.forallGroups([&](auto& groups) {\n"
        "        auto& entries = entries1.local();\n"
        "        size_t groupsFound = 0;\n"
        "        for (auto block : groups)for (auto& group : block){if (group.v > threeHundret) {\n"
        "                    entries.emplace_back(ht1.hash(group.k), group.k);\n"
        "                    groupsFound++;\n"
        "                }\n"
        "        }\n"
        "        nrGroups+=groupsFound;\n"
        "    });\n"
        "    ht1.setSize(nrGroups);\n"
        "    parallel_insert(entries1, ht1);\n"
        "\n"
        "    auto p4_start = std::chrono::steady_clock::now();\n"
        "\n"
        "// build last hashtable\n"
        "    Hashmapx<types::Integer,std::tuple<types::Integer, types::Date, types::Numeric<12, 2>,types::Char<25>>,hash>ht3;\n"
        "    tbb::enumerable_thread_specific<runtime::Stack<decltype(ht3)::Entry>>entries3;\n"
        "    auto& ord = db[\"orders\"];\n"
        "    auto o_orderkey = ord[\"o_orderkey\"].data<types::Integer>();\n"
        "    auto o_custkey = ord[\"o_custkey\"].data<types::Integer>();\n"
        "    auto o_orderdate = ord[\"o_orderdate\"].data<types::Date>();\n"
        "    auto o_totalprice =ord[\"o_totalprice\"].data<types::Numeric<12, 2>>();\n"
        "    Hashmapx<types::Integer, types::Char<25>, hash> ht2;\n"
        "// scan orders\n"
        "\n"
        "// typer ht is used only for hashing\n"
        "    auto time_merge_start = std::chrono::steady_clock::now();\n"
        "    auto found = PARALLEL_SELECT(ord.nrTuples, entries3, {char* name;\n"
        "// check if it matches the order criteria and look up the customer name\n"
        "    if (ht1.contains(o_orderkey[i])) {\n"
        "    auto hash = ht2.hash(o_custkey[i]);\n"
        "        for (auto entry = twCustomerHT.find_chain_tagged(hash); entry != runtime::Hashmap::end(); entry = reinterpret_cast<runtime::Hashmap::EntryHeader*>(entry->next)) {\n"
        "            auto t = reinterpret_cast<hybrid::Q18TWJoinTuple*>(entry);\n"
        "            if (types::Integer(t->c_custkey) == o_custkey[i]) {\n"
        "                name = t->c_name;\n"
        "            }\n"
        "        }\n"
        "        if (name != nullptr) {\n"
        "            entries.emplace_back(ht3.hash(o_orderkey[i]), o_orderkey[i],make_tuple(o_custkey[i], o_orderdate[i],o_totalprice[i], types::Char<25>::build(name)));\n"
        "            found++;\n"
        "        }\n"
        "    }\n"
        " });\n"
        "    ht3.setSize(found);\n"
        "    parallel_insert(entries3, ht3);\n"
        "\n"
        "    auto p5_start = std::chrono::steady_clock::now();\n"
        "\n"
        "    auto finalGroupOp = make_GroupBy<std::tuple<types::Integer, types::Date, types::Numeric<12, 2>,types::Char<25>, types::Integer>,types::Numeric<12, 2>, hash>([](auto& acc, auto&& value) {\n"
        "        acc += value;\n"
        "    }, zero, nrThreads);\n"
        "// scan lineitem and group by l_orderkey\n"
        "    tbb::parallel_for(tbb::blocked_range<size_t>(0, li.nrTuples, morselSize),[&](const tbb::blocked_range<size_t>& r) {\n"
        "        auto locals = finalGroupOp.preAggLocals();\n"
        "        for (size_t i = r.begin(), end = r.end(); i != end; ++i) {\n"
        "            std::tuple<types::Integer, types::Date, types::Numeric<12, 2>,types::Char<25>>* v;\n"
        "            if ((v = ht3.findOne(l_orderkey[i]))) {\n"
        "                auto& group =locals.getGroup(tuple_cat(*v, make_tuple(l_orderkey[i])));\n"
        "                group += l_quantity[i];\n"
        "            }\n"
        "        }\n"
        "    });\n"
        "    auto& result = resources.query->result;\n"
        "    auto namAttr = result->addAttribute(\"c_name\", sizeof(types::Char<25>));\n"
        "    auto ckyAttr = result->addAttribute(\"c_custkey\", sizeof(types::Integer));\n"
        "    auto okyAttr = result->addAttribute(\"o_orderkey\", sizeof(types::Integer));\n"
        "    auto datAttr = result->addAttribute(\"o_orderdate\", sizeof(types::Date));\n"
        "    auto totAttr =result->addAttribute(\"o_totalprice\", sizeof(types::Numeric<12, 2>));\n"
        "    auto sumAttr = result->addAttribute(\"sum\", sizeof(types::Numeric<12, 2>));\n"
        "    finalGroupOp.forallGroups([&](auto& groups) {\n"
        "// write aggregates to result\n"
        "        auto n = groups.size();\n"
        "        auto block = result->createBlock(n);\n"
        "        auto name = reinterpret_cast<types::Char<25>*>(block.data(namAttr));\n"
        "        auto cky = reinterpret_cast<types::Integer*>(block.data(ckyAttr));\n"
        "        auto oky = reinterpret_cast<types::Integer*>(block.data(okyAttr));\n"
        "        auto dat = reinterpret_cast<types::Date*>(block.data(datAttr));\n"
        "        auto tot = reinterpret_cast<types::Numeric<12, 2>*>(block.data(totAttr));\n"
        "        auto sum = reinterpret_cast<types::Numeric<12, 2>*>(block.data(sumAttr));\n"
        "        for (auto block : groups)for (auto& group : block) {\n"
        "                auto& k = group.k;\n"
        "                *name++ = std::get<3>(k);\n"
        "                *cky++ = get<0>(k);\n"
        "                *oky++ = get<4>(k);\n"
        "                *dat++ = get<1>(k);\n"
        "                *tot++ = get<2>(k);\n"
        "                *sum++ = group.v;\n"
        "            }\n"
        "        block.addedElements(n);\n"
        "    });\n"
        "    auto total_time_end = std::chrono::steady_clock::now();\n"
        "//    std::cout\n"
        "//            << \"P1: \"\n"
        "//            << std::chrono::duration_cast<std::chrono::milliseconds>(p2_start - p1_start)\n"
        "//                    .count()<<\",\"\n"
        "//            << \"Merge aggregate: \"\n"
        "//            << std::chrono::duration_cast<std::chrono::milliseconds>(p3_start - p2_start)\n"
        "//                    .count()<<\",\"\n"
        "//            << \"P2: \"\n"
        "//            << std::chrono::duration_cast<std::chrono::milliseconds>(p4_start - p3_start)\n"
        "//                    .count()<<\",\"\n"
        "//            << \"Merge hashing (+ P3): \"\n"
        "//            << std::chrono::duration_cast<std::chrono::milliseconds>(p5_start\n"
        "//                                                                    - p4_start)\n"
        "//                    .count()<<\",\"\n"
        "//            << \"P4: \"\n"
        "//            << std::chrono::duration_cast<std::chrono::milliseconds>(total_time_end -\n"
        "//                                                                     p5_start)\n"
        "//                    .count()<<\",\"\n"
        "//            << \"Total time \"\n"
        "//            << std::chrono::duration_cast<std::chrono::milliseconds>(\n"
        "//                    total_time_end  - total_time)\n"
        "//                    .count()\n"
        "//            << \" milliseconds.\" << std::endl;\n"
        "    leaveQuery(nrThreads);\n"
        "    return move(resources.query);\n"
        "}";
   f.close();

   // format code
   std::string format_command = std::string("astyle -q ") + cppName;
   system(format_command.c_str());

   return filename;
}


const std::string CodeGenerator::generateHybridAnotherTyperQ18() {
   // generate code
   const std::string filename = "src/hybrid/hybrid_another_typer_q18";
   const std::string cppName = filename + ".cpp";
   std::ofstream f(cppName);
   f << "/**\n"
        " * parallel version - Q18\n"
        " */\n"
        "\n"
        "#include \"hybrid/minimal_api.hpp\"\n"
        "using namespace runtime;\n"
        "using namespace std;\n"
        "using namespace types;\n"
        "std::unique_ptr<runtime::Query> hybrid_typer_q18(Database & db, size_t nrThreads, runtime::Hashmap & twCustomerHT,runtime::Hashmap & twLineitemHT, size_t firstTuple) {\n"
        "\n"
        "    auto total_time = std::chrono::steady_clock::now();\n"
        "    auto q3_hyper_start = std::chrono::steady_clock::now();\n"
        "    using namespace types;\n"
        "    using namespace std;\n"
        "    using hash = runtime::CRC32Hash;\n"
        "    auto resources = initQuery(nrThreads);\n"
        "    auto& li = db[\"lineitem\"];\n"
        "    auto l_orderkey = li[\"l_orderkey\"].data<types::Integer>();\n"
        "    auto l_quantity = li[\"l_quantity\"].data<types::Numeric<12, 2>>();\n"
        "    tbb::enumerable_thread_specific<Hashmapx<types::Integer, types::Numeric<12, 2>, hash, false>>groups;\n"
        "    const auto zero = types::Numeric<12, 2>::castString(\"0.00\");\n"
        "    auto groupOp = make_GroupBy<types::Integer, types::Numeric<12, 2>, hash>([](auto& acc, auto&& value) {\n"
        "        acc += value;\n"
        "    }, zero, nrThreads);\n"
        "\n"
        "    auto p1_start = std::chrono::steady_clock::now();\n"
        "\n"
        "    auto p2_start = std::chrono::steady_clock::now();\n"
        "\n"
        "    auto p4_start = std::chrono::steady_clock::now();\n"
        "\n"
        "// build last hashtable\n"
        "    Hashmapx<types::Integer,std::tuple<types::Integer, types::Date, types::Numeric<12, 2>,types::Char<25>>,hash>ht3;\n"
        "    tbb::enumerable_thread_specific<runtime::Stack<decltype(ht3)::Entry>>entries3;\n"
        "    auto& ord = db[\"orders\"];\n"
        "    auto o_orderkey = ord[\"o_orderkey\"].data<types::Integer>();\n"
        "    auto o_custkey = ord[\"o_custkey\"].data<types::Integer>();\n"
        "    auto o_orderdate = ord[\"o_orderdate\"].data<types::Date>();\n"
        "    auto o_totalprice =ord[\"o_totalprice\"].data<types::Numeric<12, 2>>();\n"
        "    Hashmapx<types::Integer, types::Char<25>, hash> ht2;\n"
        "// scan orders\n"
        "    std::cout<<\"here\"<<std::endl;\n"
        "// Probe both tables from vectorwise here\n"
        "    auto time_merge_start = std::chrono::steady_clock::now();\n"
        "    auto found = PARALLEL_SELECT(ord.nrTuples, entries3, {char* name;\n"
        "// check if it matches the order criteria and look up the customer name\n"
        "        runtime::CRC32Hash h1;\n"
        "        const defs::hash_t seed = 902850234;\n"
        "        auto hash1 =  h1(o_orderkey[i],seed);\n"
        "        for (auto entry = twLineitemHT.find_chain_tagged(hash1); entry != runtime::Hashmap::end(); entry = reinterpret_cast<runtime::Hashmap::EntryHeader*>(entry->next)) {\n"
        "            auto hash  =  h1(o_custkey[i],seed); //= ht2.hash(o_custkey[i]);\n"
        "            for (auto entry = twCustomerHT.find_chain_tagged(hash); entry != runtime::Hashmap::end(); entry = reinterpret_cast<runtime::Hashmap::EntryHeader*>(entry->next)) {\n"
        "                auto t = reinterpret_cast<hybrid::Q18TWJoinTuple*>(entry);\n"
        "                if (types::Integer(t->c_custkey) == o_custkey[i]) {\n"
        "                    name = t->c_name;\n"
        "                }\n"
        "            }\n"
        "            if (name != nullptr) {\n"
        "                entries.emplace_back(ht3.hash(o_orderkey[i]), o_orderkey[i],make_tuple(o_custkey[i], o_orderdate[i],o_totalprice[i], types::Char<25>::build(name)));\n"
        "                found++;\n"
        "            }\n"
        "        }\n"
        "    });\n"
        "    ht3.setSize(found);\n"
        "    parallel_insert(entries3, ht3);\n"
        "    std::cout<<\"here\"<<std::endl;\n"
        "    auto p5_start = std::chrono::steady_clock::now();\n"
        "    \n"
        "    auto finalGroupOp = make_GroupBy<std::tuple<types::Integer, types::Date, types::Numeric<12, 2>,types::Char<25>, types::Integer>,types::Numeric<12, 2>, hash>([](auto& acc, auto&& value) {\n"
        "        acc += value;\n"
        "    }, zero, nrThreads);\n"
        "// scan lineitem and group by l_orderkey\n"
        "    tbb::parallel_for(tbb::blocked_range<size_t>(0, li.nrTuples, morselSize),[&](const tbb::blocked_range<size_t>& r) {\n"
        "        auto locals = finalGroupOp.preAggLocals();\n"
        "        for (size_t i = r.begin(), end = r.end(); i != end; ++i) {\n"
        "            std::tuple<types::Integer, types::Date, types::Numeric<12, 2>,types::Char<25>>* v;\n"
        "            if ((v = ht3.findOne(l_orderkey[i]))) {\n"
        "                auto& group =locals.getGroup(tuple_cat(*v, make_tuple(l_orderkey[i])));\n"
        "                group += l_quantity[i];\n"
        "            }\n"
        "        }\n"
        "    });\n"
        "    auto& result = resources.query->result;\n"
        "    auto namAttr = result->addAttribute(\"c_name\", sizeof(types::Char<25>));\n"
        "    auto ckyAttr = result->addAttribute(\"c_custkey\", sizeof(types::Integer));\n"
        "    auto okyAttr = result->addAttribute(\"o_orderkey\", sizeof(types::Integer));\n"
        "    auto datAttr = result->addAttribute(\"o_orderdate\", sizeof(types::Date));\n"
        "    auto totAttr =result->addAttribute(\"o_totalprice\", sizeof(types::Numeric<12, 2>));\n"
        "    auto sumAttr = result->addAttribute(\"sum\", sizeof(types::Numeric<12, 2>));\n"
        "    finalGroupOp.forallGroups([&](auto& groups) {\n"
        "// write aggregates to result\n"
        "        auto n = groups.size();\n"
        "        auto block = result->createBlock(n);\n"
        "        auto name = reinterpret_cast<types::Char<25>*>(block.data(namAttr));\n"
        "        auto cky = reinterpret_cast<types::Integer*>(block.data(ckyAttr));\n"
        "        auto oky = reinterpret_cast<types::Integer*>(block.data(okyAttr));\n"
        "        auto dat = reinterpret_cast<types::Date*>(block.data(datAttr));\n"
        "        auto tot = reinterpret_cast<types::Numeric<12, 2>*>(block.data(totAttr));\n"
        "        auto sum = reinterpret_cast<types::Numeric<12, 2>*>(block.data(sumAttr));\n"
        "        for (auto block : groups)for (auto& group : block) {\n"
        "                auto& k = group.k;\n"
        "                *name++ = std::get<3>(k);\n"
        "                *cky++ = get<0>(k);\n"
        "                *oky++ = get<4>(k);\n"
        "                *dat++ = get<1>(k);\n"
        "                *tot++ = get<2>(k);\n"
        "                *sum++ = group.v;\n"
        "            }\n"
        "        block.addedElements(n);\n"
        "    });\n"
        "    auto total_time_end = std::chrono::steady_clock::now();\n"
        "    std::cout\n"
        "            << \"P1: \"\n"
        "            << std::chrono::duration_cast<std::chrono::milliseconds>(p2_start - p1_start)\n"
        "                    .count()<<\",\"\n"
        "            << \"Merge aggregate: \"\n"
        "            << std::chrono::duration_cast<std::chrono::milliseconds>(p3_start - p2_start)\n"
        "                    .count()<<\",\"\n"
        "            << \"P2: \"\n"
        "            << std::chrono::duration_cast<std::chrono::milliseconds>(p4_start - p3_start)\n"
        "                    .count()<<\",\"\n"
        "            << \"Merge hashing (+ P3): \"\n"
        "            << std::chrono::duration_cast<std::chrono::milliseconds>(p5_start\n"
        "                                                                    - p4_start)\n"
        "                    .count()<<\",\"\n"
        "            << \"P4: \"\n"
        "            << std::chrono::duration_cast<std::chrono::milliseconds>(total_time_end -\n"
        "                                                                     p5_start)\n"
        "                    .count()<<\",\"\n"
        "            << \"Total time \"\n"
        "            << std::chrono::duration_cast<std::chrono::milliseconds>(\n"
        "                    total_time_end  - total_time)\n"
        "                    .count()\n"
        "            << \" milliseconds.\" << std::endl;\n"
        "    leaveQuery(nrThreads);\n"
        "    return move(resources.query);\n"
        "}";
   f.close();

   // format code
   std::string format_command = std::string("astyle -q ") + cppName;
   system(format_command.c_str());

   return filename;
}

//const std::string CodeGenerator::generateHybridTyperQ18() {
//   // generate code
//   const std::string filename = "src/hybrid/hybrid_typer_q18";
//   const std::string cppName = filename + ".cpp";
//   std::ofstream f(cppName);
//   f << "#include \"hybrid/minimal_api.hpp\"\n"
//        "using namespace runtime;\n"
//        "using namespace std;\n"
//        "using namespace types;\n"
//        "std::unique_ptr<runtime::Query> hybrid_typer_q18(Database & db, size_t nrThreads, runtime::Hashmap & twCustomerHT,\n"
//        "                                                 std::unordered_map<std::thread::id, runtime::PartitionedDeque<1024>>& twAggrRes, size_t firstTuple) {\n"
//        "    using namespace types;\n"
//        "    using namespace std;\n"
//        "    using hash = runtime::CRC32Hash;\n"
//        "    auto resources = initQuery(nrThreads);\n"
//        "    auto& li = db[\"lineitem\"];\n"
//        "    auto l_orderkey = li[\"l_orderkey\"].data<types::Integer>();\n"
//        "    auto l_quantity = li[\"l_quantity\"].data<types::Numeric<12, 2>>();\n"
//        "    tbb::enumerable_thread_specific<Hashmapx<types::Integer, types::Numeric<12, 2>, hash, false>>groups;\n"
//        "    const auto zero = types::Numeric<12, 2>::castString(\"0.00\");\n"
//        "    auto groupOp = make_GroupBy<types::Integer, types::Numeric<12, 2>, hash>([](auto& acc, auto&& value) {\n"
//        "        acc += value;\n"
//        "    }, zero, nrThreads);\n"
//        "// scan lineitem and group by l_orderkey\n"
//        "    tbb::parallel_for(tbb::blocked_range<size_t>(firstTuple, li.nrTuples, morselSize),[&](const tbb::blocked_range<size_t>& r) {\n"
//        "        auto locals = groupOp.preAggLocals();\n"
//        "        for (size_t i = r.begin(), end = r.end(); i != end; ++i) {\n"
//        "            auto& group = locals.getGroup(l_orderkey[i]);\n"
//        "            group += l_quantity[i];\n"
//        "// locals.consume(l_orderkey[i], l_quantity[i]);\n"
//        "        }\n"
//        "    });\n"
//        "// merge tw's partial thread-local hash tables with typer's partial - single threaded\n"
//        "    /*\n"
//        "     * iterate over all partial thread results\n"
//        "     *\n"
//        "     */\n"
//        "\n"
//        "    for(auto &threadPartitions : twAggrRes) {\n"
//        "        auto locals = groupOp.preAggLocals();\n"
//        "        for(auto partition = threadPartitions.second.getPartitions().begin(); partition !=threadPartitions.second.getPartitions().end(); partition++ ) {\n"
//        "            for (auto chunk = partition->first; chunk; chunk = chunk->next) {\n"
//        "                auto elementSize = threadPartitions.second.entrySize;\n"
//        "                auto nPart = partition->size(chunk, elementSize);\n"
//        "                auto data =chunk->template data<hybrid::Q18TWAggrTuple>();\n"
//        "                for (unsigned i = 0; i < nPart; ++i) {\n"
//        "                    hybrid::Q18TWAggrTuple t = data[i];\n"
//        "                    types::Integer key = types::Integer(t.l_orderkey);\n"
//        "                    types::Numeric<12, 2> value =types::Numeric<12, 2>(t.l_quantity);\n"
//        "                    auto& group = locals.getGroup(key);\n"
//        "                    group += value;\n"
//        "                }\n"
//        "            }\n"
//        "        }\n"
//        "    }\n"
//        "\n"
//        "\n"
//        "    Hashset<types::Integer, hash> ht1;\n"
//        "    tbb::enumerable_thread_specific<runtime::Stack<decltype(ht1)::Entry>>entries1;\n"
//        "    const auto threeHundret = types::Numeric<12, 2>::castString(\"300\");\n"
//        "    std::atomic<size_t> nrGroups;\n"
//        "    nrGroups = 0;\n"
//        "    groupOp.forallGroups([&](auto& groups) {\n"
//        "        auto& entries = entries1.local();\n"
//        "        size_t groupsFound = 0;\n"
//        "        for (auto block : groups)for (auto& group : block)if (group.v > threeHundret) {\n"
//        "                    entries.emplace_back(ht1.hash(group.k), group.k);\n"
//        "                    groupsFound++;\n"
//        "                }\n"
//        "// TODO: reconsider this way of counting groups\n"
//        "        nrGroups.fetch_add(groupsFound);\n"
//        "    });\n"
//        "\n"
//        "    ht1.setSize(nrGroups);\n"
//        "    parallel_insert(entries1, ht1);\n"
//        "// build last hashtable\n"
//        "    Hashmapx<types::Integer,std::tuple<types::Integer, types::Date, types::Numeric<12, 2>,types::Char<25>>,hash>ht3;\n"
//        "    tbb::enumerable_thread_specific<runtime::Stack<decltype(ht3)::Entry>>entries3;\n"
//        "    auto& ord = db[\"orders\"];\n"
//        "    auto o_orderkey = ord[\"o_orderkey\"].data<types::Integer>();\n"
//        "    auto o_custkey = ord[\"o_custkey\"].data<types::Integer>();\n"
//        "    auto o_orderdate = ord[\"o_orderdate\"].data<types::Date>();\n"
//        "    auto o_totalprice =ord[\"o_totalprice\"].data<types::Numeric<12, 2>>();\n"
//        "    Hashmapx<types::Integer, types::Char<25>, hash> ht2;\n"
//        "// scan orders\n"
//        "\n"
//        "// typer ht is used only for hashing\n"
//        "    auto found = PARALLEL_SELECT(ord.nrTuples, entries3, {char* name;\n"
//        "// check if it matches the order criteria and look up the customer name\n"
//        "        if (ht1.contains(o_orderkey[i])) {\n"
//        "            auto hash = ht2.hash(o_custkey[i]);\n"
//        "            for (auto entry = twCustomerHT.find_chain_tagged(hash); entry != runtime::Hashmap::end(); entry = reinterpret_cast<runtime::Hashmap::EntryHeader*>(entry->next)) {\n"
//        "                auto t = reinterpret_cast<hybrid::Q18TWJoinTuple*>(entry);\n"
//        "                if (types::Integer(t->c_custkey) == o_custkey[i]) {\n"
//        "                    name = t->c_name;\n"
//        "                }\n"
//        "            }\n"
//        "            if (name != nullptr) {\n"
//        "                entries.emplace_back(ht3.hash(o_orderkey[i]), o_orderkey[i],make_tuple(o_custkey[i], o_orderdate[i],o_totalprice[i], types::Char<25>::build(name)));\n"
//        "                found++;\n"
//        "            }\n"
//        "        }\n"
//        "    });\n"
//        "    ht3.setSize(found);\n"
//        "    parallel_insert(entries3, ht3);\n"
//        "    auto finalGroupOp = make_GroupBy<std::tuple<types::Integer, types::Date, types::Numeric<12, 2>,types::Char<25>, types::Integer>,types::Numeric<12, 2>, hash>([](auto& acc, auto&& value) {\n"
//        "        acc += value;\n"
//        "    }, zero, nrThreads);\n"
//        "// scan lineitem and group by l_orderkey\n"
//        "    tbb::parallel_for(tbb::blocked_range<size_t>(0, li.nrTuples, morselSize),[&](const tbb::blocked_range<size_t>& r) {\n"
//        "        auto locals = finalGroupOp.preAggLocals();\n"
//        "        for (size_t i = r.begin(), end = r.end(); i != end; ++i) {\n"
//        "            std::tuple<types::Integer, types::Date, types::Numeric<12, 2>,types::Char<25>>* v;\n"
//        "            if ((v = ht3.findOne(l_orderkey[i]))) {\n"
//        "                auto& group =locals.getGroup(tuple_cat(*v, make_tuple(l_orderkey[i])));\n"
//        "                group += l_quantity[i];\n"
//        "            }\n"
//        "        }\n"
//        "    });\n"
//        "    auto& result = resources.query->result;\n"
//        "    auto namAttr = result->addAttribute(\"c_name\", sizeof(types::Char<25>));\n"
//        "    auto ckyAttr = result->addAttribute(\"c_custkey\", sizeof(types::Integer));\n"
//        "    auto okyAttr = result->addAttribute(\"o_orderkey\", sizeof(types::Integer));\n"
//        "    auto datAttr = result->addAttribute(\"o_orderdate\", sizeof(types::Date));\n"
//        "    auto totAttr =result->addAttribute(\"o_totalprice\", sizeof(types::Numeric<12, 2>));\n"
//        "    auto sumAttr = result->addAttribute(\"sum\", sizeof(types::Numeric<12, 2>));\n"
//        "    finalGroupOp.forallGroups([&](auto& groups) {\n"
//        "// write aggregates to result\n"
//        "        auto n = groups.size();\n"
//        "        auto block = result->createBlock(n);\n"
//        "        auto name = reinterpret_cast<types::Char<25>*>(block.data(namAttr));\n"
//        "        auto cky = reinterpret_cast<types::Integer*>(block.data(ckyAttr));\n"
//        "        auto oky = reinterpret_cast<types::Integer*>(block.data(okyAttr));\n"
//        "        auto dat = reinterpret_cast<types::Date*>(block.data(datAttr));\n"
//        "        auto tot = reinterpret_cast<types::Numeric<12, 2>*>(block.data(totAttr));\n"
//        "        auto sum = reinterpret_cast<types::Numeric<12, 2>*>(block.data(sumAttr));\n"
//        "        for (auto block : groups)for (auto& group : block) {\n"
//        "                auto& k = group.k;\n"
//        "                *name++ = std::get<3>(k);\n"
//        "                *cky++ = get<0>(k);\n"
//        "                *oky++ = get<4>(k);\n"
//        "                *dat++ = get<1>(k);\n"
//        "                *tot++ = get<2>(k);\n"
//        "                *sum++ = group.v;\n"
//        "            }\n"
//        "        block.addedElements(n);\n"
//        "    });\n"
//        "    leaveQuery(nrThreads);\n"
//        "    return move(resources.query);\n"
//        "}";
//   f.close();
//
//   // format code
//   std::string format_command = std::string("astyle -q ") + cppName;
//   system(format_command.c_str());
//
//   return filename;
//}

const std::string CodeGenerator::generateHybridTyperQ3() {
        // generate code
        const std::string filename = "src/hybrid/hybrid_typer_q3";
        const std::string cppName = filename + ".cpp";
        std::ofstream f(cppName);
        f << "/*\n"
             " * Currently running implementation\n"
             " */\n"
             "\n"
             "#include \"hybrid/minimal_api.hpp\"\n"
             "using namespace runtime;\n"
             "using namespace std;\n"
             "using namespace types;\n"
             "std::unique_ptr<runtime::Query> hybrid_typer_q3(\n"
             "        Database & db,\n"
             "        size_t nrThreads\n"
             "        ,runtime::Hashmap & twCustomerHT,\n"
             "        size_t firstTuple\n"
             ") {\n"
             "\n"
             "    using namespace types;\n"
             "    using namespace std;\n"
             "    using hash = runtime::CRC32Hash;\n"
             "    auto resources = initQuery(nrThreads);\n"
             "    // --- aggregates\n"
             "\n"
             "    // --- constants\n"
             "    auto c1 = types::Date::castString(\"1995-03-15\");\n"
             "    auto c2 = types::Date::castString(\"1995-03-15\");\n"
             "    string b = \"BUILDING\";\n"
             "    auto c3 = types::Char<10>::castString(b.data(), b.size());\n"
             "\n"
             "    auto& cu = db[\"customer\"];\n"
             "    auto& ord = db[\"orders\"];\n"
             "    auto& li = db[\"lineitem\"];\n"
             "\n"
             "    auto c_mktsegment = cu[\"c_mktsegment\"].data<types::Char<10>>();\n"
             "    auto c_custkey = cu[\"c_custkey\"].data<types::Integer>();\n"
             "    auto o_custkey = ord[\"o_custkey\"].data<types::Integer>();\n"
             "    auto o_orderkey = ord[\"o_orderkey\"].data<types::Integer>();\n"
             "    auto o_orderdate = ord[\"o_orderdate\"].data<types::Date>();\n"
             "    auto o_shippriority = ord[\"o_shippriority\"].data<types::Integer>();\n"
             "    auto l_orderkey = li[\"l_orderkey\"].data<types::Integer>();\n"
             "    auto l_shipdate = li[\"l_shipdate\"].data<types::Date>();\n"
             "    auto l_extendedprice =\n"
             "            li[\"l_extendedprice\"].data<types::Numeric<12, 2>>();\n"
             "    auto l_discount = li[\"l_discount\"].data<types::Numeric<12, 2>>();\n"
             "\n"
             "    using range = tbb::blocked_range<size_t>;\n"
             "\n"
             "    const auto add = [](const size_t& a, const size_t& b) {\n"
             "        return a + b;\n"
             "    };\n"
             "    const size_t morselSize = 100000;\n"
             "\n"
             "    //Hash table one is not completely built\n"
             "\n"
             "    // build ht for first join\n"
             "    //Filling remaining values\n"
             "    Hashset<types::Integer, hash> ht0;\n"
             "    tbb::enumerable_thread_specific<runtime::Stack<decltype(ht0)::Entry>>\n"
             "            entries0;\n"
             "    auto found0 = tbb::parallel_reduce(\n"
             "            range(firstTuple, cu.nrTuples, morselSize), 0,\n"
             "            [&](const tbb::blocked_range<size_t>& r, const size_t& f) {\n"
             "                auto found = f;\n"
             "                auto& entries = entries0.local();\n"
             "                for (size_t i = r.begin(), end = r.end(); i != end; ++i) {\n"
             "                    if (c_mktsegment[i] == c3) {\n"
             "                        entries.emplace_back(ht0.hash(c_custkey[i]), c_custkey[i]);\n"
             "                        found++;\n"
             "                    }\n"
             "                }\n"
             "                return found;\n"
             "            },\n"
             "            add);\n"
             "    ht0.setSize(found0);\n"
             "    parallel_insert(entries0, ht0);\n"
             "\n"
             "\n"
             "    // join and build second ht\n"
             "    Hashmapx<types::Integer, std::tuple<types::Date, types::Integer>, hash> ht2;\n"
             "    tbb::enumerable_thread_specific<runtime::Stack<decltype(ht2)::Entry>>\n"
             "            entries2;\n"
             "\n"
             "    auto found2 = tbb::parallel_reduce(\n"
             "            range(0, ord.nrTuples, morselSize), 0,\n"
             "            [&](\n"
             "                    const tbb::blocked_range<size_t>& r, const size_t& f) {\n"
             "                auto& entries = entries2.local();\n"
             "                auto found = f;\n"
             "                for (size_t i = r.begin(), end = r.end(); i != end; ++i)\n"
             "                    if(o_orderdate[i] < c1) {\n"
             "                        runtime::CRC32Hash h1;\n"
             "                        const defs::hash_t seed = 902850234;\n"
             "                        uint64_t output = h1(o_custkey[i],seed);\n"
             "                        for (auto entry = twCustomerHT.find_chain_tagged(output); entry !=\n"
             "                                                                                  runtime::Hashmap::end(); entry = reinterpret_cast<runtime::Hashmap::EntryHeader *>(entry->next)) {\n"
             "\n"
             "                            if (entry->hash == output) {\n"
             "                                entries.emplace_back(\n"
             "                                        ht2.hash(o_orderkey[i]), o_orderkey[i],\n"
             "                                        make_tuple(o_orderdate[i], o_shippriority[i]));\n"
             "                                found++;\n"
             "                                break;\n"
             "                            }\n"
             "                        }\n"
             "                        if(ht0.contains(o_custkey[i])){\n"
             "                            entries.emplace_back(\n"
             "                                    ht2.hash(o_orderkey[i]), o_orderkey[i],\n"
             "                                    make_tuple(o_orderdate[i], o_shippriority[i]));\n"
             "                            found++;\n"
             "                        }\n"
             "                    }\n"
             "                return found;\n"
             "            },\n"
             "            add);\n"
             "    if(found2) {\n"
             "        ht2.setSize(found2);\n"
             "        parallel_insert(entries2, ht2);\n"
             "    }\n"
             "    else {\n"
             "        ht2.setSize(1);\n"
             "        parallel_insert(entries2, ht2);\n"
             "    }\n"
             "    const auto one = types::Numeric<12, 2>::castString(\"1.00\");\n"
             "    const auto zero = types::Numeric<12, 4>::castString(\"0.00\");\n"
             "\n"
             "    tbb::enumerable_thread_specific<\n"
             "            Hashmapx<std::tuple<types::Integer, types::Date, types::Integer>,\n"
             "                    types::Numeric<12, 4>, hash, false>>\n"
             "            groups;\n"
             "\n"
             "    auto groupOp =\n"
             "            make_GroupBy<std::tuple<types::Integer, types::Date, types::Integer>,\n"
             "                    types::Numeric<12, 4>, hash>(\n"
             "                    [](auto& acc, auto&& value) {\n"
             "                        acc += value;\n"
             "                    }, zero, nrThreads);\n"
             "\n"
             "    // preaggregation\n"
             "    tbb::parallel_for(\n"
             "            tbb::blocked_range<size_t>(0, li.nrTuples, morselSize),\n"
             "            [&](const tbb::blocked_range<size_t>& r) {\n"
             "                auto locals = groupOp.preAggLocals();\n"
             "\n"
             "                for (size_t i = r.begin(), end = r.end(); i != end; ++i) {\n"
             "                    decltype(ht2)::value_type* v;\n"
             "                    if (l_shipdate[i] > c2 && (v = ht2.findOne(l_orderkey[i]))) {\n"
             "                        locals.consume(\n"
             "                                make_tuple(l_orderkey[i], get<0>(*v), get<1>(*v)),\n"
             "                                l_extendedprice[i] * (one - l_discount[i]));\n"
             "                    }\n"
             "                }\n"
             "            });\n"
             "\n"
             "    // --- output\n"
             "    auto& result = resources.query->result;\n"
             "    auto revAttr =\n"
             "            result->addAttribute(\"revenue\", sizeof(types::Numeric<12, 4>));\n"
             "    auto orderAttr = result->addAttribute(\"l_orderkey\", sizeof(types::Integer));\n"
             "    auto dateAttr = result->addAttribute(\"o_orderdate\", sizeof(types::Date));\n"
             "    auto prioAttr =\n"
             "            result->addAttribute(\"o_shippriority\", sizeof(types::Integer));\n"
             "\n"
             "    groupOp.forallGroups([&](auto& entries) {\n"
             "        // write aggregates to result\n"
             "        auto n = entries.size();\n"
             "        auto block = result->createBlock(n);\n"
             "        auto rev = reinterpret_cast<types::Numeric<12, 4>*>(block.data(revAttr));\n"
             "        auto order = reinterpret_cast<types::Integer*>(block.data(orderAttr));\n"
             "        auto date = reinterpret_cast<types::Date*>(block.data(dateAttr));\n"
             "        auto prio = reinterpret_cast<types::Integer*>(block.data(prioAttr));\n"
             "        for (auto block : entries)\n"
             "            for (auto& entry : block) {\n"
             "                *order++ = get<0>(entry.k);\n"
             "                *date++ = get<1>(entry.k);\n"
             "                *prio++ = get<2>(entry.k);\n"
             "                *rev++ = entry.v;\n"
             "            }\n"
             "        block.addedElements(n);\n"
             "    });\n"
             "\n"
             "    leaveQuery(nrThreads);\n"
             "    return move(resources.query);\n"
             "}";
        f.close();

        // format code
        std::string format_command = std::string("astyle -q ") + cppName;
        system(format_command.c_str());

        return filename;
    }

const std::string CodeGenerator::generateHybridAnotherTyperQ3() {
        // generate code
        const std::string filename = "src/hybrid/hybrid_another_typer_q3";
        const std::string cppName = filename + ".cpp";
        std::ofstream f(cppName);
        f << "/*\n"
             " * Currently running implementation\n"
             " */\n"
             "\n"
             "#include \"hybrid/minimal_api.hpp\"\n"
             "using namespace runtime;\n"
             "using namespace std;\n"
             "using namespace types;\n"
             "std::unique_ptr<runtime::Query> hybrid_typer_another_q3(\n"
             "        Database & db,\n"
             "        size_t nrThreads\n"
             "        ,runtime::Hashmap & twCustomerHT\n"
             "        ,runtime::Hashmap & twOrderHT\n"
             "        ,size_t firstTuple\n"
             ") {\n"
             "\n"
             "    using namespace types;\n"
             "    using namespace std;\n"
             "    using hash = runtime::CRC32Hash;\n"
             "    auto resources = initQuery(nrThreads);\n"
             "    // --- aggregates\n"
             "\n"
             "    // --- constants\n"
             "    auto c1 = types::Date::castString(\"1995-03-15\");\n"
             "    auto c2 = types::Date::castString(\"1995-03-15\");\n"
             "    string b = \"BUILDING\";\n"
             "    auto c3 = types::Char<10>::castString(b.data(), b.size());\n"
             "\n"
             "    auto& cu = db[\"customer\"];\n"
             "    auto& ord = db[\"orders\"];\n"
             "    auto& li = db[\"lineitem\"];\n"
             "\n"
             "    auto c_mktsegment = cu[\"c_mktsegment\"].data<types::Char<10>>();\n"
             "    auto c_custkey = cu[\"c_custkey\"].data<types::Integer>();\n"
             "    auto o_custkey = ord[\"o_custkey\"].data<types::Integer>();\n"
             "    auto o_orderkey = ord[\"o_orderkey\"].data<types::Integer>();\n"
             "    auto o_orderdate = ord[\"o_orderdate\"].data<types::Date>();\n"
             "    auto o_shippriority = ord[\"o_shippriority\"].data<types::Integer>();\n"
             "    auto l_orderkey = li[\"l_orderkey\"].data<types::Integer>();\n"
             "    auto l_shipdate = li[\"l_shipdate\"].data<types::Date>();\n"
             "    auto l_extendedprice =\n"
             "            li[\"l_extendedprice\"].data<types::Numeric<12, 2>>();\n"
             "    auto l_discount = li[\"l_discount\"].data<types::Numeric<12, 2>>();\n"
             "\n"
             "    using range = tbb::blocked_range<size_t>;\n"
             "\n"
             "    const auto add = [](const size_t& a, const size_t& b) {\n"
             "        return a + b;\n"
             "    };\n"
             "    const size_t morselSize = 100000;\n"
             "\n"
             "    //Hash table one is not completely built\n"
             "    //First hash table completely built by vetorwise\n"
             "\n"
             "    // build ht for first join\n"
             "    //Filling remaining values in hyper table\n"
             "    // join and build second ht\n"
             "    Hashmapx<types::Integer, std::tuple<types::Date, types::Integer>, hash> ht2;\n"
             "    tbb::enumerable_thread_specific<runtime::Stack<decltype(ht2)::Entry>>\n"
             "            entries2;\n"
             "\n"
             "    auto found2 = tbb::parallel_reduce(\n"
             "            range(firstTuple, ord.nrTuples, morselSize), 0,\n"
             "            [&](\n"
             "                    const tbb::blocked_range<size_t>& r, const size_t& f) {\n"
             "                auto& entries = entries2.local();\n"
             "                auto found = f;\n"
             "                for (size_t i = r.begin(), end = r.end(); i != end; ++i)\n"
             "                    if(o_orderdate[i] < c1) {\n"
             "                        runtime::CRC32Hash h1;\n"
             "                        const defs::hash_t seed = 902850234;\n"
             "                        uint64_t output = h1(o_custkey[i],seed);\n"
             "                        for (auto entry = twCustomerHT.find_chain_tagged(output); entry !=\n"
             "                                                                                  runtime::Hashmap::end(); entry = reinterpret_cast<runtime::Hashmap::EntryHeader *>(entry->next)) {\n"
             "\n"
             "                            if (entry->hash == output) {\n"
             "                                entries.emplace_back(\n"
             "                                        ht2.hash(o_orderkey[i]), o_orderkey[i],\n"
             "                                        make_tuple(o_orderdate[i], o_shippriority[i]));\n"
             "                                found++;\n"
             "                                break;\n"
             "                            }\n"
             "                        }\n"
             "                    }\n"
             "                return found;\n"
             "            },\n"
             "            add);\n"
             "    if(found2) {\n"
             "        ht2.setSize(found2);\n"
             "        parallel_insert(entries2, ht2);\n"
             "    }\n"
             "    else {\n"
             "        ht2.setSize(1);\n"
             "        parallel_insert(entries2, ht2);\n"
             "    }\n"
             "\n"
             "\n"
             "    const auto one = types::Numeric<12, 2>::castString(\"1.00\");\n"
             "    const auto zero = types::Numeric<12, 4>::castString(\"0.00\");\n"
             "\n"
             "    tbb::enumerable_thread_specific<\n"
             "            Hashmapx<std::tuple<types::Integer, types::Date, types::Integer>,\n"
             "                    types::Numeric<12, 4>, hash, false>>\n"
             "            groups;\n"
             "\n"
             "    auto groupOp =\n"
             "            make_GroupBy<std::tuple<types::Integer, types::Date, types::Integer>,\n"
             "                    types::Numeric<12, 4>, hash>(\n"
             "                    [](auto& acc, auto&& value) {\n"
             "                        acc += value;\n"
             "                    }, zero, nrThreads);\n"
             "\n"
             "\n"
             "    // preaggregation\n"
             "    tbb::parallel_for(\n"
             "            tbb::blocked_range<size_t>(0, li.nrTuples, morselSize),\n"
             "            [&](const tbb::blocked_range<size_t>& r) {\n"
             "                auto locals = groupOp.preAggLocals();\n"
             "\n"
             "                for (size_t i = r.begin(), end = r.end(); i != end; ++i) {\n"
             "\n"
             "                    if(l_shipdate[i] > c2){\n"
             "\n"
             "                        decltype(ht2)::value_type* v;\n"
             "                        if ((v = ht2.findOne(l_orderkey[i]))) {\n"
             "                        locals.consume(\n"
             "                                make_tuple(l_orderkey[i], get<0>(*v), get<1>(*v)),\n"
             "                                l_extendedprice[i] * (one - l_discount[i]));\n"
             "                        }\n"
             "                    else{\n"
             "                            runtime::CRC32Hash h1;\n"
             "                            const defs::hash_t seed = 902850234;\n"
             "                            uint64_t output = h1(l_orderkey[i],seed);\n"
             "                            for (auto entry = twOrderHT.find_chain_tagged(output); entry != runtime::Hashmap::end();entry = reinterpret_cast<runtime::Hashmap::EntryHeader *>(entry->next)) {\n"
             "                                if (entry->hash == output) {\n"
             "                                    locals.consume(\n"
             "                                            make_tuple(l_orderkey[i], o_orderdate[i], o_shippriority[i]),\n"
             "                                            l_extendedprice[i] * (one - l_discount[i]));\n"
             "                                    break;\n"
             "                                }\n"
             "                               \n"
             "                            }\n"
             "                        }\n"
             "                    }\n"
             "                }\n"
             "            });\n"
             "\n"
             "    // --- output\n"
             "    auto& result = resources.query->result;\n"
             "    auto revAttr =\n"
             "            result->addAttribute(\"revenue\", sizeof(types::Numeric<12, 4>));\n"
             "    auto orderAttr = result->addAttribute(\"l_orderkey\", sizeof(types::Integer));\n"
             "    auto dateAttr = result->addAttribute(\"o_orderdate\", sizeof(types::Date));\n"
             "    auto prioAttr =\n"
             "            result->addAttribute(\"o_shippriority\", sizeof(types::Integer));\n"
             "\n"
             "    groupOp.forallGroups([&](auto& entries) {\n"
             "        // write aggregates to result\n"
             "        auto n = entries.size();\n"
             "        auto block = result->createBlock(n);\n"
             "        auto rev = reinterpret_cast<types::Numeric<12, 4>*>(block.data(revAttr));\n"
             "        auto order = reinterpret_cast<types::Integer*>(block.data(orderAttr));\n"
             "        auto date = reinterpret_cast<types::Date*>(block.data(dateAttr));\n"
             "        auto prio = reinterpret_cast<types::Integer*>(block.data(prioAttr));\n"
             "        for (auto block : entries)\n"
             "            for (auto& entry : block) {\n"
             "                *order++ = get<0>(entry.k);\n"
             "                *date++ = get<1>(entry.k);\n"
             "                *prio++ = get<2>(entry.k);\n"
             "                *rev++ = entry.v;\n"
             "            }\n"
             "        block.addedElements(n);\n"
             "    });\n"
             "\n"
             "    leaveQuery(nrThreads);\n"
             "    return move(resources.query);\n"
             "}";
        f.close();

        // format code
        std::string format_command = std::string("astyle -q ") + cppName;
        system(format_command.c_str());

        return filename;
    }

const std::string CodeGenerator::generateHybridYetAnotherTyperQ3() {
        // generate code
        const std::string filename = "src/hybrid/hybrid_yet_another_typer_q3";
        const std::string cppName = filename + ".cpp";
        std::ofstream f(cppName);
        f <<  "/*\n"
              " * Currently running implementation\n"
              " */\n"
              "\n"
              "#include \"hybrid/minimal_api.hpp\"\n"
              "using namespace runtime;\n"
              "using namespace std;\n"
              "using namespace types;\n"
              "std::unique_ptr<runtime::Query> hybrid_typer_q3(\n"
              "    Database & db,\n"
              "    size_t nrThreads\n"
              "    ,runtime::Hashmap & twCustomerHT,\n"
              "    std::unordered_map<std::thread::id, runtime::PartitionedDeque<1024>>&twThreadData,\n"
              "    size_t firstTuple\n"
              ") {\n"
              "\n"
              "    using namespace types;\n"
              "    using namespace std;\n"
              "    using hash = runtime::CRC32Hash;\n"
              "    auto resources = initQuery(nrThreads);\n"
              "    // --- aggregates\n"
              "\n"
              "    // --- constants\n"
              "    auto c1 = types::Date::castString(\"1995-03-15\");\n"
              "    auto c2 = types::Date::castString(\"1995-03-15\");\n"
              "    string b = \"BUILDING\";\n"
              "    auto c3 = types::Char<10>::castString(b.data(), b.size());\n"
              "\n"
              "    auto& cu = db[\"customer\"];\n"
              "    auto& ord = db[\"orders\"];\n"
              "    auto& li = db[\"lineitem\"];\n"
              "\n"
              "    auto c_mktsegment = cu[\"c_mktsegment\"].data<types::Char<10>>();\n"
              "    auto c_custkey = cu[\"c_custkey\"].data<types::Integer>();\n"
              "    auto o_custkey = ord[\"o_custkey\"].data<types::Integer>();\n"
              "    auto o_orderkey = ord[\"o_orderkey\"].data<types::Integer>();\n"
              "    auto o_orderdate = ord[\"o_orderdate\"].data<types::Date>();\n"
              "    auto o_shippriority = ord[\"o_shippriority\"].data<types::Integer>();\n"
              "    auto l_orderkey = li[\"l_orderkey\"].data<types::Integer>();\n"
              "    auto l_shipdate = li[\"l_shipdate\"].data<types::Date>();\n"
              "    auto l_extendedprice =\n"
              "        li[\"l_extendedprice\"].data<types::Numeric<12, 2>>();\n"
              "    auto l_discount = li[\"l_discount\"].data<types::Numeric<12, 2>>();\n"
              "\n"
              "    using range = tbb::blocked_range<size_t>;\n"
              "\n"
              "    const auto add = [](const size_t& a, const size_t& b) {\n"
              "        return a + b;\n"
              "    };\n"
              "    const size_t morselSize = 100000;\n"
              "\n"
              "//    //Hash table one is not completely built\n"
              "//\n"
              "//    // build ht for first join\n"
              "//    //Filling remaining values\n"
              "//    Hashset<types::Integer, hash> ht0;\n"
              "//    tbb::enumerable_thread_specific<runtime::Stack<decltype(ht0)::Entry>>\n"
              "//            entries0;\n"
              "//    auto found0 = tbb::parallel_reduce(\n"
              "//                      range(firstTuple, cu.nrTuples, morselSize), 0,\n"
              "//    [&](const tbb::blocked_range<size_t>& r, const size_t& f) {\n"
              "//        auto found = f;\n"
              "//        auto& entries = entries0.local();\n"
              "//        for (size_t i = r.begin(), end = r.end(); i != end; ++i) {\n"
              "//            if (c_mktsegment[i] == c3) {\n"
              "//                entries.emplace_back(ht0.hash(c_custkey[i]), c_custkey[i]);\n"
              "//                found++;\n"
              "//            }\n"
              "//        }\n"
              "//        return found;\n"
              "//    },\n"
              "//    add);\n"
              "//    ht0.setSize(found0);\n"
              "//    parallel_insert(entries0, ht0);\n"
              "//\n"
              "//\n"
              "//    // join and build second ht\n"
              "//    Hashmapx<types::Integer, std::tuple<types::Date, types::Integer>, hash> ht2;\n"
              "//    tbb::enumerable_thread_specific<runtime::Stack<decltype(ht2)::Entry>>\n"
              "//            entries2;\n"
              "//\n"
              "//    auto found2 = tbb::parallel_reduce(\n"
              "//                      range(0, ord.nrTuples, morselSize), 0,\n"
              "//                      [&](\n"
              "//    const tbb::blocked_range<size_t>& r, const size_t& f) {\n"
              "//        auto& entries = entries2.local();\n"
              "//        auto found = f;\n"
              "//        for (size_t i = r.begin(), end = r.end(); i != end; ++i)\n"
              "//            if(o_orderdate[i] < c1) {\n"
              "//                runtime::CRC32Hash h1;\n"
              "//                const defs::hash_t seed = 902850234;\n"
              "//                uint64_t output = h1(o_custkey[i],seed);\n"
              "//                for (auto entry = twCustomerHT.find_chain_tagged(output); entry !=\n"
              "//                        runtime::Hashmap::end(); entry = reinterpret_cast<runtime::Hashmap::EntryHeader *>(entry->next)) {\n"
              "//\n"
              "//                    if (entry->hash == output) {\n"
              "//                        entries.emplace_back(\n"
              "//                            ht2.hash(o_orderkey[i]), o_orderkey[i],\n"
              "//                            make_tuple(o_orderdate[i], o_shippriority[i]));\n"
              "//                        found++;\n"
              "//                        break;\n"
              "//                    }\n"
              "//                }\n"
              "//                if(ht0.contains(o_custkey[i])) {\n"
              "//                    entries.emplace_back(\n"
              "//                        ht2.hash(o_orderkey[i]), o_orderkey[i],\n"
              "//                        make_tuple(o_orderdate[i], o_shippriority[i]));\n"
              "//                    found++;\n"
              "//                }\n"
              "//            }\n"
              "//        return found;\n"
              "//    },\n"
              "//    add);\n"
              "//    if(found2) {\n"
              "//        ht2.setSize(found2);\n"
              "//        parallel_insert(entries2, ht2);\n"
              "//    }\n"
              "//    else {\n"
              "//        ht2.setSize(1);\n"
              "//        parallel_insert(entries2, ht2);\n"
              "//    }\n"
              "    const auto one = types::Numeric<12, 2>::castString(\"1.00\");\n"
              "    const auto zero = types::Numeric<12, 4>::castString(\"0.00\");\n"
              "//\n"
              "//    tbb::enumerable_thread_specific<\n"
              "//    Hashmapx<std::tuple<types::Integer, types::Date, types::Integer>,\n"
              "//             types::Numeric<12, 4>, hash, false>>\n"
              "//             groups;\n"
              "//\n"
              "    auto groupOp =\n"
              "        make_GroupBy<std::tuple<types::Integer, types::Date, types::Integer>,\n"
              "        types::Numeric<12, 4>, hash>(\n"
              "    [](auto& acc, auto&& value) {\n"
              "        acc += value;\n"
              "    }, zero, nrThreads);\n"
              "//\n"
              "//    // preaggregation\n"
              "//    tbb::parallel_for(\n"
              "//        tbb::blocked_range<size_t>(0, li.nrTuples, morselSize),\n"
              "//    [&](const tbb::blocked_range<size_t>& r) {\n"
              "//        auto locals = groupOp.preAggLocals();\n"
              "//\n"
              "//        for (size_t i = r.begin(), end = r.end(); i != end; ++i) {\n"
              "//            decltype(ht2)::value_type* v;\n"
              "//            if (l_shipdate[i] > c2) {\n"
              "//                runtime::CRC32Hash h1;\n"
              "//                const defs::hash_t seed = 902850234;\n"
              "//                uint64_t output = h1(l_orderkey[i],seed);\n"
              "//                for (auto entry = twCustomerHT.find_chain_tagged(output); entry !=\n"
              "//                        runtime::Hashmap::end(); entry = reinterpret_cast<runtime::Hashmap::EntryHeader *>(entry->next)) {\n"
              "//                    locals.consume(\n"
              "//                        make_tuple(l_orderkey[i], o_orderdate[i], o_shippriority[i]),\n"
              "//                        l_extendedprice[i] * (one - l_discount[i]));\n"
              "//                }\n"
              "//            }\n"
              "//        }\n"
              "//    });\n"
              "\n"
              "\n"
              "    // merge tw's partial thread-local hash tables with typer's partial thread-local hash tables\n"
              "    tbb::parallel_for_each(twThreadData.begin(), twThreadData.end(), [&](auto& threadPartitions) {\n"
              "        auto locals = groupOp.preAggLocals();\n"
              "        for(auto partition = threadPartitions.second.getPartitions().begin(); partition !=threadPartitions.second.getPartitions().end(); partition++ ) {\n"
              "            for (auto chunk = partition->first; chunk; chunk = chunk->next) {\n"
              "                auto elementSize = threadPartitions.second.entrySize;\n"
              "                auto nPart = partition->size(chunk, elementSize);\n"
              "                auto data = chunk->template data<hybrid::Q3TectorTuple>();\n"
              "                for (unsigned i = 0; i < nPart; ++i) {\n"
              "\n"
              "                    hybrid::Q3TectorTuple t =data[i];\n"
              "//                    hybrid::Q3TyperKey tectorKey =std::make_tuple(types::Integer(t.l_orderkey),types::Date(t.o_orderdate),types::Integer(t.o_shippriority));\n"
              "//                    hybrid::Q3TyperValue tectorValue = std::make_tuple(types::Numeric<12, 4>(t.revenue));\n"
              "                    locals.consume(\n"
              "                            std::make_tuple(types::Integer(t.l_orderkey),types::Date(t.o_orderdate),types::Integer(t.o_shippriority))\n"
              "                            ,types::Numeric<12, 4>(t.revenue)\n"
              "                    );\n"
              "//                    locals.consume(\n"
              "//                            make_tuple(t.l_orderkey, t.o_orderdate, t.o_shippriority),\n"
              "//                            t.revenue);\n"
              "                }\n"
              "            }\n"
              "        }\n"
              "    });\n"
              "    // --- output\n"
              "    auto& result = resources.query->result;\n"
              "    auto revAttr =\n"
              "        result->addAttribute(\"revenue\", sizeof(types::Numeric<12, 4>));\n"
              "    auto orderAttr = result->addAttribute(\"l_orderkey\", sizeof(types::Integer));\n"
              "    auto dateAttr = result->addAttribute(\"o_orderdate\", sizeof(types::Date));\n"
              "    auto prioAttr =\n"
              "        result->addAttribute(\"o_shippriority\", sizeof(types::Integer));\n"
              "\n"
              "    groupOp.forallGroups([&](auto& entries) {\n"
              "        // write aggregates to result\n"
              "        auto n = entries.size();\n"
              "        auto block = result->createBlock(n);\n"
              "        auto rev = reinterpret_cast<types::Numeric<12, 4>*>(block.data(revAttr));\n"
              "        auto order = reinterpret_cast<types::Integer*>(block.data(orderAttr));\n"
              "        auto date = reinterpret_cast<types::Date*>(block.data(dateAttr));\n"
              "        auto prio = reinterpret_cast<types::Integer*>(block.data(prioAttr));\n"
              "        for (auto block : entries)\n"
              "            for (auto& entry : block) {\n"
              "                *order++ = get<0>(entry.k);\n"
              "                *date++ = get<1>(entry.k);\n"
              "                *prio++ = get<2>(entry.k);\n"
              "                *rev++ = entry.v;\n"
              "            }\n"
              "        block.addedElements(n);\n"
              "    });\n"
              "\n"
              "    leaveQuery(nrThreads);\n"
              "    return move(resources.query);\n"
              "}";
        f.close();

        // format code
        std::string format_command = std::string("astyle -q ") + cppName;
        system(format_command.c_str());

        return filename;
    }

} // namespace hybrid
